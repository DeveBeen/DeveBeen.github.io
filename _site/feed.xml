<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-05-07T19:32:30+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">The Minimum Viable Model</title><subtitle>Artificial Intelligence trends and concepts made easy.</subtitle><author><name>Armando Maynez</name></author><entry><title type="html">Vue VS React</title><link href="http://localhost:4000/Vue-React.html" rel="alternate" type="text/html" title="Vue VS React" /><published>2023-05-07T00:00:00+09:00</published><updated>2023-05-07T00:00:00+09:00</updated><id>http://localhost:4000/Vue-React</id><content type="html" xml:base="http://localhost:4000/Vue-React.html"><![CDATA[<hr />
<h2 id="1-vuejs">1. Vue.js?</h2>
<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fu5WAs%2Fbtr9qC5h0xP%2FfbpbQzd5tlxv3ilL6ukcAK%2Fimg.png" alt="image" /></p>
<ul>
  <li>웹 화면을 만들기 위한 프론트엔드 라이브러리이자 점진적 프레임워크이다.</li>
  <li>배우기 쉽게 만들어져 프로트엔드 개발에 있어 react와 함께 대중적인 오픈소스 js 프레임워크이다.</li>
  <li>SPA를 구축하는데 사용한다.</li>
  <li>MVVM패턴의 ViewModel에 해당하여, UI코드와 데이터제어 제어 로직을 분리했다.
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcVeP4L%2FbtrvZIubnnT%2FCZKbN7k7uHkvIssYIAgjWk%2Fimg.png" alt="image" /></li>
</ul>

<p>[구성요소]</p>
<ul>
  <li>View(html DOM): 사용자에게 보이는 화면이다.</li>
  <li>Model(JS): 데이터를 담는 용기로 보통은 서버에서 가져온 javascript 객체를 저장한다.</li>
  <li>ViewModel: View와 Model의 중간 영역으로 DomListener와 DataBinding을 제공하는 영역이다.</li>
  <li>DOM: HTML 문서에 들어가는 요소(tag, class, attribute 등)의 정보를 담고 있는 트리 형태의 데이터이다.</li>
  <li>DOM Listener: DOM의 변경에 대한 즉각적으로 반응하여 특정 로직을 수행하는 장치이다.</li>
  <li>Data Binding: View에 표시되는 내용과 모델의 데이터를 동기화한다.</li>
  <li>
    <p>Vue에서는 기본적으로 단방향 데이터바인딩으로 컴포넌트간 통신은 상위 컴포넌트에서 하위컴포넌트로 전달한다.</p>
  </li>
  <li>Vue.js로 Hello World 출력 프로그램 짜기 <br /></li>
</ul>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html&gt;</span>
  <span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">"utf-8"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">name=</span><span class="s">"viewport"</span> <span class="na">content=</span><span class="s">"width=device-width, initial-scale=1.0"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;title&gt;</span>Hello World<span class="nt">&lt;/title&gt;</span>
  <span class="nt">&lt;/head&gt;</span>
  <span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">"app"</span><span class="nt">&gt;&lt;/div&gt;</span>
    <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
    <span class="nt">&lt;script&gt;</span>
      <span class="k">new</span> <span class="nc">Vue</span><span class="p">({</span>
        <span class="na">el</span><span class="p">:</span> <span class="dl">"</span><span class="s2">#app</span><span class="dl">"</span><span class="p">,</span>
        <span class="na">data</span><span class="p">:</span> <span class="p">{</span>
          <span class="na">message</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Vue.js - Hello World </span><span class="dl">"</span><span class="p">,</span>
        <span class="p">},</span>
      <span class="p">});</span>
    <span class="nt">&lt;/script&gt;</span>
  <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>
<p><br /></p>

<hr />
<h2 id="2-react">2. React?</h2>
<p><img src="https://lessipe.com/file/course/15561812324742.png" alt="image" /></p>
<ul>
  <li>React는 javascript 라이브러리 중 하나로 사용자 인터페이스를 만들기 위해 사용한다. 페이스북(메타)와 개발자 및 기업들인 공동체에 의해 유지보수된다.</li>
  <li>Vue와 같이 SPA 개발 시 자주 사용된다.</li>
</ul>

<p>[React의 특징]</p>
<ol>
  <li>Data Flow : 데이터의 흐름이 단방향성이다.</li>
  <li><a href="#단어정리">Component</a> 기반 구조 : React는 UI를 여러 컴포넌트로 쪼개진 독립된 컴포넌트를 조합하여 구현한다.</li>
  <li>Virtual Dom : Vue와 같이 데이터를 객체로 간주하는 트리구조의 형태를 가진다.</li>
  <li>Props : 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달하는 데이터로 자식 컴포넌트에서는 props를 변경 불가능하게 하는 특징을 가지고 있다.</li>
  <li>State : 컴포넌트 내부에 선언하여 값을 바꾸는 용도이며, 동적인 데이터를 다룰 때 사용된다.</li>
  <li>JSX : JS 문법을 확장시킨 것으로, 필수사용은 아니지만 UI 코드 작업 시 시각적으로 도움이 된다.</li>
</ol>

<hr />
<h2 id="3-프레임워크-라이브러리">3. 프레임워크? 라이브러리?</h2>
<p>[프레임워크?]</p>
<ul>
  <li>프레임워크(Framework)는 제어의 역전 개념이 적용된 소프트웨어의 기반 구조가 되는 대표적인 기술이다.</li>
</ul>

<p>[프레임워크의 특징]</p>
<ul>
  <li>특정 개념들의 추상화를 제공하는 재사용이 가능한 여러 클래스나 컴포넌트로 구성되어 있습니다.</li>
  <li>추상적인 개념들이 문제를 해결하기 위해 같이 작업하는 방법을 정의합니다.</li>
  <li>높은 수준에서 패턴들을 조작화 할 수 있습니다.</li>
</ul>

<p>[라이브러리?]</p>
<ul>
  <li>라이브러리(Library)는 활용가능한 도구들의 집합으로 개발자가 만들어둔 클래스를 호출하여 사용하는 방식으로 활용할 수 있다.</li>
</ul>

<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F2344774D577B359522" alt="image" /></p>

<p>[프레임워크 VS 라이브러리]</p>
<ul>
  <li>둘의 가장 큰 차이점은 제어 흐름에 대한 주도성이 누구에게 있냐에 있다.</li>
  <li>프레임워크는 전체적인 흐름을 프레임워크가 가지고 있으며 사용자는 그 안에서 코드를 짜 넣는 반면 라이브러리는 사용자가 전체적인 흐름을 가지고 있어 사용자가 주도성을 가지고 있다.</li>
  <li>간단하게 말해서 프레임워크는 누가 이미 만들어 놓은 틀에서 조금씩의 조작으로 만들어가는 기술이고, 라이브러리는 누군가가 만들어 놓은 또는 내가 만든 기능들을 호출하여 사용하면서 만들어가는 기술이다.</li>
</ul>

<hr />
<h2 id="4-vue-vs-react">4. Vue VS React?</h2>
<ul>
  <li>위에 프레임워크와 라이브러리의 차이를 알았으니 Vue와 React의 사용처에 대한 조금은 왔을거라고 생각한다. 간단히 말해서 정해진 규칙대로 만들어진 프레임워크로 코드 통일성을 가지고 싶다면 Vue, 자유로운 코드 형식으로 자유도가 높은 코드를 사용하고 싶으면 React를 사용하면 된다.</li>
  <li>위에 특성으로 Vue는 자유도가 떨어지고 Vue에서 제공해주는 문법으로만 코딩을 해야한다는 답답함이 있고, React는 개발자마다 코드가 다 달라 어떤 코딩을 해야하는지 감을 잡기 쉽지 않고 스타일을 통일할 때도 지속적인 커뮤니케이션 비용이 발생한다.</li>
  <li>아직 감이 안온다면 아래 예시 내옹을 보자.</li>
</ul>

<p>[Vue를 사용해야 하는 상황]</p>
<ul>
  <li>프론트엔드 초보자 : 제어 흐름이 정해져있고 통일성이 있기에 초보자 입장에서 집입장벽이 낮고 쉽게 코드 통일하기 좋다.</li>
  <li>개발자들의 코드를 많이 참고하는 사람 : 위에서 말한 것과 동일하게 Vue에서 정해진 규칙으로 코딩하기에 개발자들의 코드를 읽고 이해하기가 쉽다.</li>
</ul>

<p>[React를 사용해야 하는 상황]</p>
<ul>
  <li>프론트엔드 실력자 : 제어 흐름이 개발자에게 달려 있어 개발자의 생각으로 커스터마이징이 가능하며 높은 자유도를 가져 방대한 생태계가 존재한다.</li>
  <li>규모가 큰 프로젝트 : 컴포넌트를 작은 단위로 쪼개 UI를 재사용하는 방면에서 코드의 직관성이 보장되기에 대규모 프로젝트를 진행할 때 적절하다.</li>
</ul>

<p>[둘의 시장 점유율]</p>

<p><img src="https://www.dong-ki.com/wp-content/uploads/2022/06/image-7.png" alt="image" /></p>
<ul>
  <li>NPM trend에서 각 프레임워크의 다운로드 수치이다.</li>
  <li>보는 것과 같이 자유도가 높은 면에서 이점이 많기에 당연히 react가 점유율이 높다는 것을 볼 수 있다.</li>
</ul>

<hr />
<h2 id="단어정리">단어정리</h2>
<ul>
  <li>Component : 독립적인 단위의 소프트웨어 모듈이다.</li>
</ul>]]></content><author><name>Armando Maynez</name></author><category term="opinion" /><category term="front-end" /><category term="vue" /><category term="react" /><category term="basic" /><summary type="html"><![CDATA[Vue VS React]]></summary></entry><entry><title type="html">Node.js 환경 VS 브라우저 환경</title><link href="http://localhost:4000/Environment.html" rel="alternate" type="text/html" title="Node.js 환경 VS 브라우저 환경" /><published>2023-05-07T00:00:00+09:00</published><updated>2023-05-07T00:00:00+09:00</updated><id>http://localhost:4000/Environment</id><content type="html" xml:base="http://localhost:4000/Environment.html"><![CDATA[<hr />
<h2 id="1-nodejs란">1. Node.js란?</h2>
<ul>
  <li>Node.js는 <a href="#단어정리">V8 JavaScript 엔진</a>으로 빌드되어 외부에 있는  JavaScript 코드를 실행하는 오픈소스 <a href="#단어정리">크로스 플렛폼</a> 백엔드 <a href="#단어정리">런타임 환경</a>이다.</li>
  <li>Node.js를 사용하여 개발자는 자바스크립트를 사용해서 명령줄 도구를 작성하고 서버측 스크립팅을 실행하여 페이지를 사용자의 웹 브라우저로 보내기 전에 동적 웹 페이지 컨텐츠를 생성할 수 있다.</li>
  <li>즉, Node.js는 웹 어플리케이션을 통합하는 JS를 어디에서나 적용하고 쓸 수 있는 패러다임을 제공하는 서버측 스크립트, 클라이언트측 스크립트가 아닌 단일 프로그래밍 언어이다.</li>
  <li>Node.js는 이벤트 기반, 논 블로킹 I/O 모델이라는 특성으로 높은 처리 성능을 가지고 있다는 것이 특징이다.</li>
</ul>

<p>[이벤트 기반]<br />
<img src="https://velog.velcdn.com/images%2Feunnbi%2Fpost%2Fd27f23af-53fd-44fc-81f3-74d10a2c6c7d%2Fimage.png" alt="image" /></p>
<ul>
  <li>이벤트 기반은 이벤트 루프를 통해 이벤트 발생 시 미리 지정한 작업을 수행하는 방식을 이야기 한다.</li>
  <li>이벤트 루프는 여러 이벤트가 동시 발생할 때 어떤 것을 우선 처리할 지 우선순위를 판단하는 사이클이다.</li>
  <li>Node.js는 이벤트가 종료될 때까지 이벤트 처리를 위한 작업을 반복한다.</li>
</ul>

<p>[논 블로킹 I/O 모델]<br /></p>
<ul>
  <li>작업에는 두 가지 종류가 있는데 동시에 실행될 수 있는 작업과 동시에 실행될 수 없는 작업이있다. 이 중 논 블로킹은 이전 작업이 완료될 때까지 대기하지 않고 다음 작업을 수행하는 것을 말한다.</li>
  <li>Node.js는 싱글스레드 논 블로킹 방식으로 스레드는 하나지만 비동기식으로 이전작업의 완료를 기다리지 않고 다음 작업을 실행한다.</li>
</ul>

<hr />
<h2 id="2-브라우저">2. 브라우저?</h2>
<ul>
  <li>브라우저 환경을 알기 위해서 먼저 브라우저가 정확히 뭔지 알아야한다.</li>
  <li>브라우저는 사전적 의미로는 인터넷상에서 웹에 연결 시켜주는 윈도우 기반의 소프트웨어이다. 쉽게 말해서 사용자인 우리가 웹에 접근하기 위한 도구를 브라우저라고 정의한다.</li>
  <li>아래 사진과 같이 우리가 아는 브라우저는 여러 종류가 있다.<br />
<img src="https://t1.daumcdn.net/cfile/tistory/2670B14957BA8B2E0C" alt="image" /><br /></li>
</ul>

<hr />
<h2 id="3-nodejs-브라우저-환경">3. Node.js, 브라우저 환경?</h2>
<ul>
  <li>그렇다면 여기에 환경을 붙이면 정확히 무엇을 말하는 것이냐? 우리가 보통 개발 환경하면은 어떤 뜻으로 해석하는가? 그렇다 개발을 위해 셋팅하는 환경을 말한다.</li>
  <li>위에 두가지도 직역하자면 Node.js 환경은 Node.js를 사용하기 위해 셋팅하는 환경, 브라우저 환경은 브라우저를 사용하기 위해 셋팅하는 환경을 말한다.</li>
  <li>그러면 셋팅을 누가 하느냐? 개발환경은 보통 개발자가 언어를 채택하여 셋팅하는 방식이지만 위에 두 환경은 그 셋팅 주체가 JavaScript로 통일(약속)되어 있다.
<img src="https://miro.medium.com/v2/resize:fit:1400/1*BPSx-c--z6r7tY29L19ukQ.png" alt="image" /></li>
</ul>

<hr />
<h2 id="4-nodejs-환경과-브라우저-환경의-차이점">4. Node.js 환경과 브라우저 환경의 차이점</h2>
<ul>
  <li>이제 확실하게 Node.js 환경이 뭔지, 브라우저 환경이 무엇인지 알았을 것이다. 그렇다면 이 둘의 차이점이 무엇인지 알아보자.</li>
</ul>

<p>[Node.js와 브라우저의 차이점]</p>
<ol>
  <li>존재목적 : 브라우저는 HTML,CSS,JS를 실행하여 사용자의 웹 화면에 랜더링하는 것이 주 목적이지만 Node.js는 서버 개발 환경을 제공하는 것이 주목적이다. 이에 둘 다 JS의 코어인 <a href="#단어정리">ECMAScript</a>를 실행하나 이외 추가적인 API는 서로 호환되지 않는다.</li>
  <li>API : 브라우저는 시각적 표현이 필요한 것과 다르게 node.js는 필요가 없어 UI관련 API에도 차이가 있고, Node.js는 브라우저에서 사용가능한 window,document 객체가 없어 웹 플렛폼 API가 Node.js에는 호환되지 않는다.</li>
  <li>JS Engine : Node.js는 구글 Chrome 브라우저에서 사용하는 V8 엔진을 자바스크립트 실행 엔진으로 사용하지만 브라우저는 종류와 버전에 따라 엔진이 다양하다.</li>
  <li>제어 : Node.js에서는 우리가 직접환경을 제어하여 버전 이동이 가능하지만 브라우저는 환경이 정해져 있기에 불가능하다.
<br />
<br />
    <ul>
      <li>이러한 차이점들로 Node.js는 컴퓨터의 깊은 부분을 제어하는 백엔드 기술에 최적화 되어 있음을 알 수 있다.</li>
    </ul>
  </li>
</ol>

<hr />
<h2 id="단어정리">단어정리</h2>
<ul>
  <li>V8 JavaScript 엔진 : 웹 브라우저를 만드는데 기반을 제공하는 오픈소스 자바스크립트 엔진으로 자바스크립트를 바이트 코드로 변환하여 읽어 웹 브라우저 내부의 속도 개선을 위해 만들어졌다.</li>
  <li>크로스 플렛폼 : 컴퓨터 프로그램, 운영체제, 프로그래밍 언어 등 여러종류의 컴퓨터 플랫폼에서 동작할 수 있다는 뜻이다.</li>
  <li>런타임 환경 : 런타임을 위해 시스템 적인 자원을 운영체제에게 요청하기 위해 엑세스할 수 있도록 해주는 환경을 말한다.</li>
  <li>ECMAScript : Ecma International이 ECMA-262 기술 규격에 따라 정의하고 있는 표준화된 스크립트 프로그래밍 언어를 말하며 자바 스크립트를 표준화하기 위해 사용된다.</li>
</ul>]]></content><author><name>Armando Maynez</name></author><category term="opinion" /><category term="front-end" /><category term="node.js" /><category term="browser" /><category term="basic" /><summary type="html"><![CDATA[Node.js 환경 VS 브라우저 환경]]></summary></entry><entry><title type="html">REST-API? RESTFUL-API?</title><link href="http://localhost:4000/REST-API-RESTFUL-API.html" rel="alternate" type="text/html" title="REST-API? RESTFUL-API?" /><published>2023-05-06T00:00:00+09:00</published><updated>2023-05-06T00:00:00+09:00</updated><id>http://localhost:4000/REST-API-RESTFUL-API</id><content type="html" xml:base="http://localhost:4000/REST-API-RESTFUL-API.html"><![CDATA[<hr />
<h2 id="1-rest란-무엇인가">1. REST란 무엇인가?</h2>
<ul>
  <li>REST(REpresentational State Transfer)는 정보를 주고 받는 방식에 있어 개발자들이 널리 쓰이는 일종의 형식으로 기본적으로 웹의 기존 기술과 HTTP 기술을 그대로 사용하기에 웹의 장점을 최대한 사용할 수 있는 아키텍쳐 스타일이다.</li>
</ul>

<p>[REST의 구성요소]</p>
<ul>
  <li>URI : 서버의 존재하는 고유한 ID를 가진 자원으로 Client는 url을 이용하여 자원에 대한 조작을 Server에 요청한다.</li>
  <li>Method : <a href="#단어정리">HTTP 프로토콜의 Method</a>를 사용한다.</li>
  <li>Representation of Resouce : Client가 Server와 주고 받는 데이터 형식으로 JSON, XML, TEXT, <a href="#단어정리">RSS</a> 등이 있다.</li>
</ul>

<p>[REST의 특징]</p>
<ul>
  <li>Server-Client 구조 : 자원을 요청하는 쪽이 Client, 자원을 가진 쪽이 Server로 서로의 역할을 확실히 하므로 의존성을 줄인다.</li>
  <li>Stateless(무상태) : Client의 context를 Server에 저장하지 않아 세션과 쿠키같은 context 정보를 신경쓰지 않아도 되기에 개발이 쉬워지고, Server는 각 요청이 모두 별개로 처리 되기에 일관성이 있다. 이때문에 서비스의 자유도가 높다.</li>
  <li>Cacheable(캐시 처리 가능) : 웹 표준 HTTP 프로토콜을 그대로 사용하기에 HTTP 프로토콜의 캐싱 기능을 사용할 수 있다.</li>
  <li>Layered System(계층구조) : Client는 REST API 서버만 호출하며 REST Server는 다층 계층으로 구성될 수 있다.</li>
  <li>Code-On-Demend : 서버로부터 스크립트를 받아서 클라이언트에서 실행한다. (무조건 충족할 필요는 없다.)</li>
  <li>인터페이스 일관성 : URI로 지정한 자원에 대한 조작을 통일되고 한정적인 인터페이스로 수행하며 HTTP 표준 프로토콜에 따르는 모든 플랫폼에서 사용이 가능하다.</li>
</ul>

<p>[REST가 필요한 이유]</p>
<ul>
  <li>어플리케이션의 분리 통합을 위해서 필요하다.</li>
  <li>다양한 클라이언트의 등장으로 다양한 브라우저와 모바일에서도 통신이 가능해야 한다.</li>
</ul>

<hr />

<h2 id="2-rest-api">2. REST API?</h2>
<ul>
  <li>API는 인터넷상에서 데이터를 전송하고 이용할 수 있게 하는 소프트웨어 인터페이스이다.</li>
  <li>REST 개념과 합쳐서 REST API는 REST 기반 API이다. REST API를 사용하는 이유는 REST 기반으로 시스템을 분산해 확장성과 재사용성을 높여 유지보수와 운용을 편리하게 하기 위함이다.</li>
  <li>따라서 REST API는 HTTP를 잘 사용하기위해, URI와 HTTP메소드를 사용해서, URI로 어떤 자원에 접근할 것인지, 메소드로 어떤 행위를 할것인지 표현하여 설계된 API를 말한다.</li>
</ul>

<p>[REST API의 특징]</p>
<ul>
  <li>REST는 HTTP 표준을 기반으로 구현하므로, HTTP를 지원하는 프로그램 언어로 클라이언트, 서버를 구현할 수 있다.</li>
  <li>각 요청이 어떤 동작이나 정보를 위한 것인지를 요청의 모습으로 추론이 가능하다.</li>
</ul>

<p>[REST API 설계 방법]</p>
<ol>
  <li>URI은 정보의 자원을 표현 해야 한다.</li>
  <li>자원에 대한 행위는 HTTP method로 표현하며 이는 URI에 포함되지 않는다.</li>
</ol>

<hr />

<h2 id="3-restful-api">3. RESTFUL API?</h2>
<ul>
  <li>REST API는 아래와 같은 설계규칙이 있다.</li>
</ul>

<p>[설계규칙]</p>
<ol>
  <li>URI는 명사를 사용한다. (Resource 이름은 동사가 아닌 명사)</li>
  <li>슬래시(/)로 계층관계를 표현하며 해당 기호는 마지막에 오지 않는다.</li>
  <li>Underbar(_)를 사용하지 않고 hyphen(-)을 사용한다.</li>
  <li>URI는 소문자로만 구성한다.</li>
  <li>HTTP 응답상태 코드를 명시하여 잘못된 요청에 대한 피드백을 남겨야한다.</li>
  <li>URI에는 파일 확장자가 포함되지 않는다.</li>
</ol>

<ul>
  <li>RESTFUL API는 이러한 설계규칙을 잘 지켜서 설계된 REST API를 말한다.</li>
</ul>

<p><img src="https://velog.velcdn.com/images/gomuzom/post/4d78ca3b-d4ee-4723-b55b-6a12d5566e30/image.png" alt="image" /></p>

<hr />

<h2 id="단어정리">단어정리</h2>
<p><br />
[HTTP 프로토콜의 Method]<br /></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">이름</th>
      <th style="text-align: center">기능</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">GET</td>
      <td style="text-align: center">Read : URL이 가진 정보를 검색하기 위해 서버에 요청한다.</td>
    </tr>
    <tr>
      <td style="text-align: center">POST</td>
      <td style="text-align: center">Create : 클라이언트에서 서버로 전달하려는 정보를 보낸다.</td>
    </tr>
    <tr>
      <td style="text-align: center">PUT</td>
      <td style="text-align: center">Update : 데이터 전부 내용을 갱신할 때 주로 사용</td>
    </tr>
    <tr>
      <td style="text-align: center">PATCH</td>
      <td style="text-align: center">Update : 데이터 일부 내용을 갱신할 때 주로 사용</td>
    </tr>
    <tr>
      <td style="text-align: center">DELETE</td>
      <td style="text-align: center">Delete : 정보를 삭제하는 메소드이나 보안 문제로 대부분 비활성화</td>
    </tr>
  </tbody>
</table>

<p><br /></p>
<ul>
  <li>RSS : Real Simple Syndication의 약자로 뉴스나 블로그에서 주로 사용하는 콘텐츠 표현 파일형식이다.</li>
</ul>]]></content><author><name>Armando Maynez</name></author><category term="opinion" /><category term="front-end" /><category term="api" /><category term="basic" /><summary type="html"><![CDATA[REST-API, RESTFUL-API가 무엇인지 알아보자.]]></summary></entry><entry><title type="html">Session? Cookie?</title><link href="http://localhost:4000/Session-Cookie.html" rel="alternate" type="text/html" title="Session? Cookie?" /><published>2023-05-04T00:00:00+09:00</published><updated>2023-05-04T00:00:00+09:00</updated><id>http://localhost:4000/Session-Cookie</id><content type="html" xml:base="http://localhost:4000/Session-Cookie.html"><![CDATA[<hr />

<h2 id="1-쿠키cookie란">1. 쿠키(Cookie)란?</h2>
<ul>
  <li>쿠키는 클라이언트(브라우저) 로컬에 저장되는 키와 값이 들어있는 작은 데이터 파일로 클라이언트의 상태 정보를 로컬에 저장했다가 참조한다.</li>
  <li>사용자 인증이 유효한 시간을 명시할 수 있고, 유효 시간이 정해지면 브라우저가 종료되어도 인증이 유지된다는 특징이 있다.</li>
  <li>하나의 쿠기값은 4KB로 클라이언트에 300개까지 쿠키를 저장가능하며 도메인당 20개의 값만 가질 수 있다.</li>
  <li><a href="#단어정리">Response Header</a>에 Set-Cookie 속성을 사용하면 클라이언트에 쿠키를 만들 수 있습니다.</li>
  <li>쿠키는 사용자가 따로 요청하지 않아도 브라우저가 Request시에 <a href="#단어정리">Request Header</a>를 넣어서 자동으로 서버에 전송합니다.</li>
</ul>

<p>[쿠키를 사용하는 이유]</p>
<ul>
  <li>세션관리(Session Management) : 서버에 저장해야 할 정보를 관리한다.</li>
  <li>개인화(Personalization) : 사용자 선호, 테마 등을 세팅한다.</li>
  <li>트래킹(Tracking) : 사용자의 행동을 기록하고 분석한다.</li>
</ul>

<p>[쿠키의 구성요소]</p>
<ul>
  <li>이름 : 쿠키를 구별하는데 사용되는 이름</li>
  <li>값 : 쿠키의 이름과 관련된 값</li>
  <li>유효시간 : 쿠키의 유지시간</li>
  <li>도메인 : 쿠키를 전송할 도메인</li>
  <li>경로 : 쿠키를 전송할 경로</li>
  <li>보안 : 보안 연결 설정</li>
  <li>HttpOnly : HTTP 외 다른 통신 사용 가능</li>
</ul>

<p>[쿠키의 동작순서]<br />
1) 클라이언트가 페이지를 요청<br />
2) 서버에서 쿠키를 생성하여 HTTP 헤더에 쿠키를 포함하여 응답<br />
3) 브라우저가 종료되어도 쿠키 만료시간이 있다면 클러이언트에서 보관<br />
4) 같은 요청 시 HTTP 헤더에 쿠키를 포함시켜 보냄<br />
5) 서버에서 쿠키를 읽어 이전 상태 정보를 변경 할 필요가 있을 때 쿠키를 업데이트 하여 변경된 쿠키를 HTTP 헤더에 포함시켜 응답<br /></p>

<p><img src="https://velog.velcdn.com/images%2Fxchdtk%2Fpost%2F0051a36c-41be-4b63-a618-c8b8e490f254%2Fimage.png" alt="image" /></p>

<p>[쿠키의 단점]</p>
<ul>
  <li>쿠키에 대한 정보를 매번 헤더에 추가하여 보내기에 트래픽을 많이 발생시킨다.</li>
  <li>쿠기의 대한 정보가 유출되면 보안 문제도 발생하기에 보안이 취약하다.</li>
</ul>

<hr />

<h2 id="2-세션session이란">2. 세션(Session)이란?</h2>
<ul>
  <li>세션은 쿠키를 기반하고 있지만 사용자 정보 파일을 브라우저에 저장하는 쿠키와 달리 서버 측에서 관리하는 데이터 파일이다.</li>
  <li>서버에서는 클라이언트를 구분하기 위해 세션 ID를 부여하며 웹 브라우저가 서버에 접속해서 브라우저를 종료할 때까지 인증상태를 유지하고 접속시간에 제한을 두어 일정 시간 응답이 없다면 정보가 유지되지 않게 설정이 가능하다.</li>
  <li>클라이언트가 Request를 보내면, 해당 서버의 엔진이 클라이언트에게 유일한 ID를 부여하는 데 이것이 세션 ID입니다.</li>
</ul>

<p>[세션의 동작순서]<br />
1) 클라이언트가 서버에 Resource를 요청합니다.<br />
2) 서버에서는 HTTP Request를 통해 쿠키에서 세션 ID를 확인을 한 후에 없으면 쿠키를 셋팅하여 새로 발행한 세션 ID 보냅니다.<br />
3) 클라이언트는 HTTP Request 헤더에 세션 ID를 포함하여 원하는 Resource를 요청을 합니다.<br />
4) 서버는 세션 ID를 통해 해당 세션을 찾아 클라이언트 상태 정보를 유지하며 적절한 응답을 합니다.<br /></p>

<p>[세션의 장점]</p>
<ul>
  <li>신뢰할 수 있는 유저인지 서버에서 추가로 확인 가능 (최초 접속 때를 제외하고 세션ID만 사용)</li>
  <li>저장 개수나 용량 제한 없어 서버 용량이 충분하다면 큰 용량을 허용한다.</li>
  <li>데이터를 <a href="#단어정리">Hash Table</a>에 저장. 한 번에 많은 정보를 하나의 세션 객체에 저장 가능</li>
  <li>세션 ID만 보내므로, 세션의 크기가 커도 네트워크 부하가 거의 없다.</li>
  <li>서버에 저장되므로 클라이언트의 웹브라우저에 의존하지 않아도 된다.</li>
</ul>

<p>[세션의 단점]</p>
<ul>
  <li>사용자에 대한 정보를 서버에 두기 때문에 사용자가 많아질수록 서버 메모리를 많이 차지한다.</li>
</ul>

<hr />

<h2 id="3-쿠키-or-세션">3. 쿠키 or 세션?</h2>
<ul>
  <li>세션은 결국 쿠키를 사용한 것이기에 쿠키와 세션은 비슷한 역할을 하며, 동작원리도 비슷하다.</li>
  <li>둘이 비슷한 역할을 하나 쿠키는 서버 자원을 전혀 사용하지 않고, 세션은 서버의 자원을 사용해 사용자의 정보가 저장되는 위치가 다르다는 차이점이 있다.</li>
  <li>보안 면에서 세션이 더 우수하며, 요청 속도는 쿠키가 세션보다 더 빠릅니다. 그 이유는 세션은 서버의 처리가 필요하기 때문입니다.
보안면에서 쿠키는 클라이언트 로컬에 저장되기에 request에서 <a href="#단어정리">스니핑</a>을 당할 우려가 있어 보안에 취약하지만 세션은 세션 ID만 저장하고 서버에서 그것을 구분해서 처리하기에 보안성이 좋다.<br />
<img src="data:image/png;base64,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" alt="image" /></li>
</ul>

<hr />

<h2 id="4-로컬스토리지localstorage">4. 로컬스토리지(LocalStorage)</h2>
<ul>
  <li>LocalStorage는 Local:헌지의,Storage:저장소로 말 그대로 현지의 저장소. 즉, 사용자의 로컬에 존재하는 저장소를 말한다.</li>
  <li>로컬 스토리지는 만료시간이 존재하지 않아 페이지나 브러우저를 닫아도 반 영구적으로 유지되는 저장소이다.</li>
  <li>로컬 스토리지는 key와 value 형태로 이루어진다.<br /></li>
</ul>

<p>[로컬 스토리지 메소드,속성]<br /></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">이름</th>
      <th style="text-align: center">구분</th>
      <th style="text-align: center">쿠키</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">setitem(key,value)</td>
      <td style="text-align: center">메서드</td>
      <td style="text-align: center">해당 키 값으로 데이터를 저장</td>
    </tr>
    <tr>
      <td style="text-align: center">getitem(key)</td>
      <td style="text-align: center">메서드</td>
      <td style="text-align: center">해당 키 값의 이름을 가진 데이터를 가져옴</td>
    </tr>
    <tr>
      <td style="text-align: center">removeitem</td>
      <td style="text-align: center">메서드</td>
      <td style="text-align: center">해당 키 값의 이름을 가진 데이터를 삭제</td>
    </tr>
    <tr>
      <td style="text-align: center">key(index)</td>
      <td style="text-align: center">메서드</td>
      <td style="text-align: center">해당 인덱스를 가진 키 값을 가져옴</td>
    </tr>
    <tr>
      <td style="text-align: center">clear()</td>
      <td style="text-align: center">메서드</td>
      <td style="text-align: center">모든 데이터를 삭제</td>
    </tr>
    <tr>
      <td style="text-align: center">length</td>
      <td style="text-align: center">속성</td>
      <td style="text-align: center">저장된 데이터 수를 가져옴</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="단어정리">단어정리</h2>
<ul>
  <li>Response Header : 위치 또는 서버 자체에 대한 정보(이름, 버전 등)와 같이 응답에 대한 부가적인 정보를 갖는 헤더이다.</li>
  <li>Request Header : HTTP 요청에서 사용되지만 메시지의 컨텐츠와는 관련이 없는 헤더이다.</li>
  <li>Hash Table : 해시 테이블은 (Key, Value)로 데이터를 저장하는 자료구조 중 하나로 빠르게 데이터를 검색할 수 있는 자료구조이다.</li>
  <li>스니핑 : 네트워크 트래픽을 도청하는 과정을 말한다.<br />
<img src="data:image/png;base64,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" alt="image" /></li>
</ul>]]></content><author><name>Armando Maynez</name></author><category term="opinion" /><category term="front-end" /><category term="network" /><category term="basic" /><summary type="html"><![CDATA[세션과 쿠키 그리고 로컬스토리지가 무엇인지 알아보자.]]></summary></entry><entry><title type="html">Javascript</title><link href="http://localhost:4000/Java-Basic.html" rel="alternate" type="text/html" title="Javascript" /><published>2023-04-29T00:00:00+09:00</published><updated>2023-04-29T00:00:00+09:00</updated><id>http://localhost:4000/Java-Basic</id><content type="html" xml:base="http://localhost:4000/Java-Basic.html"><![CDATA[<hr />

<h2 id="1-javascript란">1. JavaScript란?</h2>
<ul>
  <li>js는 웹 페이지의 생동감을 불어 넣기 위해 만들어진 프로그래밍 언어이다.</li>
  <li>HTML과 CSS언어와는 다르게 C언어, java와 같은 일반 프로그래밍 언어와 비슷하게 생겼으며 HTML,CSS,JS를 이용하는 프론트엔드 초보자에게는 어려운 부분이다.</li>
  <li>js는 객체기반의 스크립트 언어로 기본적으로 웹 브라우저에서 해석되는 인터ㅡ리터 언어이다. Node.js와 같은 프레임 워크를 사용해 서버 프로그래밍도 가능하다.</li>
</ul>

<p>[JS의 특징]</p>
<ul>
  <li>동적이며 타입을 명시할 필요가 없는 인터프리터 언어이다.</li>
  <li>객체지향 프로그래밍과 함수형 프로그래밍을 모두 표현 가능하다.</li>
  <li>HTML의 내용, 속성, 스타일을 변경할 수 있다.</li>
</ul>]]></content><author><name>Armando Maynez</name></author><category term="opinion" /><category term="front-end" /><category term="javascript" /><category term="basic" /><summary type="html"><![CDATA[JavaScript가 무엇인지 알아보고 기초 문법에 대해 알아보자.]]></summary></entry><entry><title type="html">Git,Github?</title><link href="http://localhost:4000/Git-Github.html" rel="alternate" type="text/html" title="Git,Github?" /><published>2023-04-29T00:00:00+09:00</published><updated>2023-04-29T00:00:00+09:00</updated><id>http://localhost:4000/Git-Github</id><content type="html" xml:base="http://localhost:4000/Git-Github.html"><![CDATA[<hr />

<h2 id="1-githubgit이란">1. Github,Git이란?</h2>
<ul>
  <li>git이란 Distributed version control system이다. 즉, 직역하면 분산 버전 관리 시스템으로 분산해서 버전을 관리(변화,변경)를 하는 시스템을 말한다.</li>
  <li>github라는 Web Service의 주요 기능인 원격 저장소 역할을 한다.</li>
  <li>GoogleDrive 같은 원격 저장소와는 버전으로 관리 되어 하위 버전 이동 또는 버전 업데이트가 자유롭다.</li>
  <li>github는 이러한 git을 사용하여 현업과 프로젝트 버전관리등의 유용한 기능을 하는 개발자의 커뮤니티이다.</li>
</ul>

<hr />

<h2 id="2-그래서-버전-관리를-왜-하는데">2. 그래서 버전 관리를 왜 하는데?</h2>
<ul>
  <li>다양한 이유가 있지만 먼저 간단하게 시각적으로 보자면 아래와 같은 상황을 방지하기 위함이다.
    <blockquote>
      <p>“조별과제_김원빈.pptx”<br />
“조별과제_김원빈_성준수정.pptx”<br />
“조별과제_김원빈_성준수정_최종.pptx”<br />
“조별과제_김원빈_성준수정_최종_의최종.pptx”<br />
“조별과제_김원빈_성준수정_최종_의최종_을철현수정.pptx”<br />
“조별과제_김원빈_성준수정_최종_의최종_을철현수정_최종.pptx”<br />
 . . .</p>
    </blockquote>
  </li>
  <li>위와 같은 방식을 버전 관리라고 한다. 즉, 과거 파일을 백업해두는 방법이다. 위 같은 방식도 작업하기엔 문제도 없고 백업 기능도 있기에 괜찮아 보일 수 있으나 큰 문제가 있다.</li>
  <li>위 파일은 조별과제이다. 개인이 작업하는게 아니라 조원들이 관리하다가 너도나도 파일을 수정한다면 파일 백업 의미가 없어져 버린다.</li>
  <li>아래와 같은 이유로 깃허브를 사용한다고 할 수 있다.</li>
</ul>

<p>[팀 프로젝트 버전 관리의 문제]<br />
1) 여러 개의 파일 버전을 일관되게 관리하기 힘들다.(누가 가장 최신 파일을 가지고 있는지 모른다.<br />
2) 누가/무엇을/어떻게 변경하였는지 기록,확인,공유가 어렵다.<br />
3) 서로의 변경 내역을 덮어씌우거나 지워버려 오류가 발생할 수 있다.<br />
4) 변경 전 버전을 특정할 수 없으므로 내용을 이전 상태로 돌리기도 어렵다.<br />
<img src="https://user-images.githubusercontent.com/61172021/92212736-65180200-eecd-11ea-8756-eb669f047081.png" alt="image" /></p>

<hr />
<h2 id="3-git-flow-개념-이해하기">3. Git-Flow 개념 이해하기</h2>
<ul>
  <li>git-flow는 과거 Vincent Driessen이라는 사람의 블로그를 통해 알려진 Git 개발 방식의 방법론으로 기능적인 것이 아닌 약속의 의미를 가지고 있는 방법론이다.</li>
  <li>git-flow는 아래와 같이 5가지 <a href="#단어정리">브랜치(branch)</a>로 나뉜다.</li>
</ul>

<p>[Git-Flow 전략]<br /></p>
<ul>
  <li><b>master</b> : 기준인 역할을 하는 브랜치로 제품을 배포하는 최종 브랜치이다.<br /></li>
  <li><b>develop</b> : 개발할 때의 메인 브랜치로. 구현해야할 기능이 발생하면 feature 브랜치를 생성 및 개발, 구현 완료 후 develop 브랜치로 병합한다. 다음 배포 버전까지 개발 완료 후 <a href="#단어정리">QA Test</a>를위해 release 브랜치로 <a href="#단어정리">머지(merge)</a>된다<br /></li>
  <li><b>feature</b> : 이슈 및 기능을 구현하기 위해 생성하는 브랜치로 develop 브랜치에서 생성한다. 기능 구현이 완료되면 develop 브랜치에 머지하고 feature 브랜치는 삭제한다.<br /></li>
  <li><b>release</b> : develop에 저장되어 QA를 진행하여 통과 시 master 브랜치에 머지하는 QA 진행 브랜치이다.<br /></li>
  <li><b>hotfix</b> : 게임을 한 사람들에게는 익숙한 이름의 브랜치로 배포 후 release 브랜치에서 발견 못한 버그가 발생하여 긴급한 수정이 필요할 때 생성하는 브랜치이다. master에서 생성하고 수정 후 master, develop 브랜치에 머지하고 hotfix 브렌치는 삭제한다.<br /></li>
</ul>

<h2 id="4-git-flow-상세">4. Git-Flow 상세</h2>
<ul>
  <li>위에 git-flow에 사용되는 브랜치를 알아봤다. 하지만 저렇게 정의를 해두는 것은 알겠지만 정의만 보고 흐름이 잘 보이지 않는다.</li>
  <li>그렇다면 각 브랜치의 모습을 하나씩 보며 흐름을 이해해보자.</li>
</ul>

<p><b>[master branch]</b><br /></p>
<ul>
  <li>배포가능한 상태를 관리하는 브랜치<br /></li>
</ul>

<p><b>[develop branch]</b><br /></p>
<ul>
  <li>다음 버전을 개발하는 브랜치</li>
  <li>평소 개발 시 기준이 되는 개발 브랜치이다.<br /></li>
</ul>

<p><img src="https://lh4.googleusercontent.com/CZlG9QPr4RYMGAJ3z2ihWV6UuyJRqEmYSwm4Du3AeaFCc2-lrrEG-rWA6YkWKyFvAye_uKv0123vXLt4JY_dey_KkDk8VdPAHvDOgzLg2pwTE0k6li-dL_YUWpP-8Ck8Xrbx4ouS" alt="image" /></p>

<p><b>[feature branch]</b><br /></p>
<ul>
  <li>기능을 개발하는 브랜치로 develop 브랜치에서 뻗어나와 좀 더 세부적으로 개발하기 위한 역할을 하는 보조 브랜치이다.</li>
  <li>feature 브랜치는 기능을 완성할 때까지 유지하며, 완료되면 develop 브랜치에 머지한다.</li>
  <li>물론 기능이 별로다 싶으면 버린다. (develop에 머지하지 않았으니 영향을 미치지 않는다. 그러니 확실하다 싶으면 머지하는 것이 중요하다.)</li>
</ul>

<p><img src="https://lh6.googleusercontent.com/J9X6SYLWwSLiLb6JAd_HBMFeTXpzwIZIMUkqtJpXZzi5cg42gIHLx3F99X-wSVIoFEc0u7NCY08yl-xTFolFlwfR0ytJWxZntoZS3-5WWq_oAlIO_MfJWKQfQYur_8ed7D_vzPF3" alt="image" /></p>

<p><b>[release branch]</b><br /></p>
<ul>
  <li>필터 역할을 하는 브랜치로 develop에서 master로 머지하기 전에 최종 수정을 위해 QA하는 브랜치이다.</li>
  <li>중요한 것은 release 브랜치에서 수정된 사항이 있으면 develop 브랜치에도 머지를 시켜줘야 다음 버전 개발에 꼬이지 않는다.</li>
</ul>

<p><img src="https://lh5.googleusercontent.com/4mXmoEov9sqhCEo6vxFF8eOrvrc5hyo0SvW6YLgJMoauuejV0ketnm9yxjc1JyiUqjZnWwMCQr71JATvU1mAlxk3NPrQcglpWTpaIbIL1aiJbVXJ2e4DSocSo5eeG_I6zOQVfZ9A" alt="image" /></p>

<p><b>[hotfix branch]</b><br /></p>
<ul>
  <li>배포 버전에서 긴급 수정이 필요할 때, master에서 분기하는 브랜치이다.</li>
  <li>긴급 수정을 하는 동시에 develop 브랜치에서 아무러 작용없이 개발할 수 있어 나뉜 브랜치이며, 수정 후 master에 바로 머지를 한다.</li>
  <li>이 또한 중요한 것은 수정 후 release 브랜치처럼 develop 브랜치에도 머지해야하는 것이다.</li>
</ul>

<p><img src="https://lh5.googleusercontent.com/_jcNDU-WEGylP-1Z5CFOIYBDjwOmaqUi6DslzKGZ39rts9IXEEBdyq7NvF1jrlXnLg2dn_mL-tnvINUrUFSx4UOlAkOov_EpwW6eF1zRHYEK8xRB__GyG5HrpEWWFjHNa23WhF8I" alt="image" /></p>

<ul>
  <li>최종적으로 보는 흐름</li>
</ul>

<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdSKdav%2FbtrCVRy7XUT%2FLKQdnMfcWPsCPf6ogKMq90%2Fimg.png" alt="image" /></p>

<h2 id="단어정리">단어정리</h2>
<ul>
  <li>브랜치(branch) : 직역하면 나뭇가지란 뜻으로 직역 뜻과 같이 나뭇가지 처럼 뻗어나가는 가지 중 한가지를 말하며 Git 개발 작업에서는 이를 하나의 작업라인을 말할 때 사용한다.</li>
  <li>QA Test : Quality Assurance Test로 품질 보증 시험으로 소프트웨어가 개발 되었을 때, 이것이 적절한 디자인 패턴을 적재적소에 사용해 확작성이 있고 유지보수가 좋은 코드인지, 기존 소프트웨어 보다 좋은 또는 편리한 기능을 제시하는지, 기존 소프트웨어보다 성능면에서 좋은지 검증하는 단계라 볼 수 있다.</li>
  <li>머지(merge) : 병합이라는 뜻을 가진 것처럼 나뭇가지로 뻗어나간 수 많은 나뭇가지 중 어떠한 나뭇가지인 작업라인을 또다른 작업라인으로 병합 시켜준다는 말이다.</li>
</ul>]]></content><author><name>Armando Maynez</name></author><category term="opinion" /><category term="front-end" /><category term="git" /><category term="basic" /><summary type="html"><![CDATA[Git,Github가 무엇인지 알아보고, Git Flow 개념을 이해해보자.]]></summary></entry><entry><title type="html">JSON,XML,YAML</title><link href="http://localhost:4000/JSON-XML-YAML.html" rel="alternate" type="text/html" title="JSON,XML,YAML" /><published>2023-04-28T00:00:00+09:00</published><updated>2023-04-28T00:00:00+09:00</updated><id>http://localhost:4000/JSON-XML-YAML</id><content type="html" xml:base="http://localhost:4000/JSON-XML-YAML.html"><![CDATA[<hr />

<h2 id="1-json-javascript-object-notation">1. JSON (JavaScript Object Notation)</h2>
<ul>
  <li>데이터를 저장, 전송할 때 사용되는 경량의 DATA 교환 형식 JavaScript에서 객체를 만들 때 사용하는 단순한 텍스트 형식인 표현식이다.</li>
  <li>클라이언트와 서버가 주고 받는 요청(Request)와 응답(Response) 사이에 담겨있는 데이터의 형식 중 하나이다.
-JSON은 데이터 포멧일 뿐이고 단순히 데이터를 표시하는 방법이다.</li>
</ul>

<p>[JSON 형식의 장점]</p>
<ul>
  <li>대부분의 프로그래밍 언어에서 JSON을 핸들링할 수 있도록 라이브러리를 제공한다.</li>
  <li>XML보다 최소한의 용량으로 데이터 전송이 가능하며, 구조 정의의 용이성과 가독성이 좋다.</li>
  <li>내용이 최소한의 정보만 가지고 있기에 용량이 줄어들고 빠른 속도를 가지며, 언어가 독립적이고 사용하기 쉽다.</li>
</ul>

<p>[JSON 형식의 단점]</p>
<ul>
  <li>장점과 반대로 내용이 최소한의 정보만 가지고 있어 의미파악이 힘들다.</li>
  <li>경량의 데이터 교환형식이기에 대용량의 데이터 송수신에는 부적합하다.</li>
  <li>XML은 사용처마다 요구되는 구조와 형태를 잘 갖췄는지 스키마를 이용해 검증이 가능하지만 JSON은 해당 기능을 지원하지 않는다.</li>
  <li>주석을 달지 못하고, 문법 오류에 취약하다.</li>
</ul>

<p><img src="https://media.licdn.com/dms/image/C560DAQEXmiSIYftM5Q/learning-public-crop_288_512/0/1629482233685?e=2147483647&amp;v=beta&amp;t=Cxx1JriYNY21m914uW3MS3YEhig1ezopPqS0941wD7s" alt="image" /></p>

<p>[JSON 형식의 구조]</p>
<ul>
  <li>JSON 형식의 구조는 key:value 형태의 구조를 가지고 있다. 중괄호 {}로 감싸며, 이는 객체(Object)가 나올 것을 의미한다.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  "나이":30,
  "이름":"홍길동",
  "특기":["달리기","수영"]
}
</code></pre></div>    </div>
  </li>
</ul>

<hr />

<h2 id="2-xml-extensible-markup-language">2. XML (Extensible Markup Language)</h2>
<ul>
  <li>XML은 데이터를 정의하는 규칙을 제공하는 markup 언어로 다른 프로그래밍 언어와는 다르게 자체적으로 컴퓨팅하는 작업을 수행할 수 없다.</li>
  <li>대신 구조적 데이터 관리를 위해 모든 프로그래밍 언어 또는 소프트웨어를 구현할 수 있다.</li>
  <li>태그라는 markup 기호를 사용하여 문서 내용에 영향을 주지 않고 사용하여 데이터의 유용성을 높인다.</li>
</ul>

<p>[XML의 특징]</p>
<ul>
  <li>표준성 : <a href="#단어정리">W3C</a>에서 표준화를 주도, SGML과 HTML의 한계를 극복하기 위해 만든 표준 인터넷 언어이다.</li>
  <li>분리성 : 표현과 내용이 분리되어 있고 XML 문서는 데이터의 구조와 내용을 기술하고 있으며, 스타일 시트를 이용하여 다양한 방식으로 데이터를 표현한다.</li>
  <li>단순성 : XML 문서는 텍스트로 간단하게 되어 있어 하드웨어나 소프트웨어에 의존하지 않고 읽어 들일 수 있다는 장점이 있다.</li>
  <li>호환성 : 위 단순성의 특성으로 다양한 시스템간에 상호 작용을 중계하는데 XML 사용이 가능하다.</li>
  <li>수용성 : HTML과 같이 현재 인터넷에서 가장 많이 사용되는 HTTP 프로토콜을 이용하여 전달한다.</li>
  <li>확장성 : XML은 확장성 있는 태그를 사용, 어떤 분야의 데이터도 명확하게 기술이 가능하다.</li>
  <li>SEQ : 문서의 의미 있는 태그를 사용하여 원하는 데이터를 쉽게 찾을 수 있는 장점이 있어 검색엔진최적화(SEQ)에 유리하다.
<img src="https://i0.wp.com/hanamon.kr/wp-content/uploads/2021/06/HTML-vs-XML.png?fit=1280%2C844&amp;ssl=1" alt="image" />
    <blockquote>
      <h3 id="xml과-html">[XML과 HTML]<br /></h3>
      <ul>
        <li>XML은 Data를 전달하는 것에 포커스를 맞춘 언어라면 HTML은 Data를 표현하는 것에 포커스를 맞춘 언어이다. <br /></li>
        <li>HTML의 태그는 이미 약속한 태그만 사용이 가능하지만 XML은 사용자가 임의로 만들어서 사용이 가능합니다.
~~~xml
&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;</li>
      </ul>
    </blockquote>
  </li>
</ul>
<마트>
    <과일류>
        사과, 바나나
    </과일류>
    <채소류>
        양배추
    </채소류>
    <라면류>
        일품라면
    </라면류>
</마트>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
---

## 3. YAML (YAML Ain't Makeup Language)
- YAML도 데이터 표현 양식의 한 종류이며 아래와 같은 특징을 가진다.

[YAML의 특징]
- yaml은 인간이 보고 이해하기 쉬운 형태를 가지고 있어 최근 많이 활용되는 데이터 포멧입니다.
- 기본적으로 들여쓰기를 원칙으로 하며 JSON과 비슷하게 Key:Value 형태를 가지고 있다.

~~~yaml
Servers:
    - name : Server1
      administrator : Kim
      created : 20050103132749
      status : active
    - name : Server2
      administrator : Lee
      created : 20210101000000
      status : active
</code></pre></div></div>

<hr />

<h2 id="단어정리">단어정리</h2>
<ul>
  <li>W3C(World Wide Web Consortium) : 월드 와이드 웹을 위한 표준을 개발하고 관리하는 조직으로 팀 버너스리를 중심으로 설립된 조직이다.</li>
</ul>]]></content><author><name>Armando Maynez</name></author><category term="opinion" /><category term="front-end" /><category term="datatype" /><category term="basic" /><summary type="html"><![CDATA[JSON,XML,YAML이 각각 무엇인지 그 차이가 뭔지 알아보자.]]></summary></entry><entry><title type="html">CSR/SSR,MAP/SPA</title><link href="http://localhost:4000/CSR-SSR-MAP-SPA.html" rel="alternate" type="text/html" title="CSR/SSR,MAP/SPA" /><published>2023-04-17T00:00:00+09:00</published><updated>2023-04-17T00:00:00+09:00</updated><id>http://localhost:4000/CSR-SSR-MAP-SPA</id><content type="html" xml:base="http://localhost:4000/CSR-SSR-MAP-SPA.html"><![CDATA[<hr />
<h2 id="1-csr-client-side-renderring">1. CSR (Client Side Renderring)</h2>
<ul>
  <li>CSR(Client Side Rendering)은 말 그대로 Client 측에서 <a href="#단어정리">렌더링(Rendering)</a>이 이루어지는 방식을 말한다. CSR의 작업은 다음과 같은 순서로 이루어진다.<br />
    <blockquote>
      <p>1) 클라이언트(브라우저)가 웹 서버에게 요청을 보낸다.<br />
2) Web 서버는 비어있는 HTML 문서인 index.html을 반환한다.(index.html은 비어있는 파일)<br />
3) HTML 문서에 있는 어플리케이션 자바스크립트 링크를 참고하여 웹 서버로부터 자바스크립트 파일을 다운받는다.<br />
4) 추가로 필요한 데이터가 있으면 서버에서 추가적으로 요청하여 가져온다.<br />
5) 사용자에게 화면을 보여준다.<br /></p>
    </blockquote>
  </li>
</ul>

<p>[CSR 방식의 장점]</p>
<ul>
  <li>빠른 <a href="#단어정리">인터렉션</a>을 구현할 수 있다.</li>
  <li>View Rendering을 브라우저에게 담당시키므로서 서버 트레픽을 감소시키고, 사용자에게 더 빠른 인터렉션을 제공해준다.</li>
  <li>새로고침이 발생하지 않아 사용자가 불편함을 느낄 수 있습니다.</li>
</ul>

<p>[CSR 방식의 단점]</p>
<ul>
  <li>첫 페이지 로딩 속도가 Server Side Rendering 보다 다소 느립니다.</li>
  <li><a href="#단어정리">검색엔진최적화(SEO)</a>에 대한 추가 보완 작업이 필요하다.</li>
</ul>

<h2 id="2-ssr-server-side-rendering">2. SSR (Server Side Rendering)</h2>
<ul>
  <li>SSR(Server Side Rendering)은 CSR 방식과 다르게 Server에서 User에게 보여줄 화면을 미리 페이지를 모두 구성하여 렌더링이 이루어지는 방식을 말한다. SSR의 작업은 다음과 같은 순서로 이루어진다.
    <blockquote>
      <p>1) CSR과 다르게 웹 서버에서 비어있는 HTML 파일이 아닌 완성된 HTML 문서와 동적으로 처리 가능한 코드를 가져온다.<br />
2) CSR과 다르게 서버에 두번 요청할 필요없이 클라이언트에서 바로 User에게 화면을 보여준다.</p>
    </blockquote>
  </li>
</ul>

<p>[SSR 방식의 장점]</p>
<ul>
  <li>완성된 형태의 HTML 파일을 서버로 부터 받으므로 크롤링하기에 적합, 검색엔진최적화(SEO) 관점에서 유리하다.</li>
  <li>서버에 이미 로딩을 완료해서오므로 첫 로딩 시간이 매우 짧다.</li>
</ul>

<p>[SSR 방식의 단점]</p>
<ul>
  <li>페이지 요청시 서버에서 페이지를 받아오므로 깜박이는 현상이 나타나 UX는 좋지 않다는 단점이 있다.</li>
  <li>화면에서 바꾸지 않아도 되는 부분을 계속하여 렌더링을 하여 서버가 과부화되기 쉽다.</li>
  <li>사용자가 동적 움직임을 보일 때, 서버에서 계속하여 데이터를 가져오기 때문에 과부하되기 쉽다.</li>
  <li>처음 HTML 문서를 받을 때, <a href="#단어정리">TTV</a>가 먼저 일어나고 이후 클릭을 해야 <a href="#단어정리">TTI</a>가 일어나기에 사용자가 빠르게 웹 사이트를 볼 수 있지만 TTV와 TTI의 공백이 길어 반응이 없을 수도 있다.</li>
</ul>

<h2 id="3-spa-single-page-aplication">3. SPA (Single Page Aplication)</h2>
<ul>
  <li>SPA는 CSR 방식을 사용하는 하나의 Page로 구성된 Application이다. 하지만 react, vue, angular 등이 있고 특히 react는 Next.js와 Gatsby.js에서 SSG을 제공하기 때문에 SPA라고 모두 CSR 방식을 사용하는 것은 아니다.</li>
  <li>처음 요청 시 딱 한 페이지만 불러오고 페이지 이동 시 기존 페이지에서 내부를 수정하여 보여주는 방식이다. 이에 페이지 리로딩 없이 서버에서 내부 수정 시 필요한 데이터만 가져온다.</li>
</ul>

<p>[SPA 방식의 장점]</p>
<ul>
  <li>필요한 리소스만 부분적으로 로딩하여 클라이언트가 처음 요청한 정적 리소스와 추가적인 데이터는 모두 캐시에 저장된다.</li>
  <li>페이지의 부분적인 요소만 갱신하기 때문에 전체적으로 트레픽이 감소한다.</li>
  <li>페이지를 새로고침하지 않기 때문에 <a href="#단어정리">UX(User Experience)</a>에서 매우 좋다.</li>
</ul>

<p>[SPA 방식의 단점]</p>
<ul>
  <li>Web Application에 필요한 정적 리소스를 한번에 다운로드 받기에 초기에 구동 속도가 느리다.</li>
  <li>검색 엔진이 크롤링할 때, Application이 로드 되기 전에 빈 상태의 코드를 크롤링하게 검색엔진최적화(SEO)가 어렵다.</li>
  <li>SSR에선 사용자의 정보를 서버측에서 관리하지만 CSR 방식은 클라이언트에서 가져오기에 정보를 저장할 공간이 마땅치 않아 보안이 취약하다.</li>
</ul>

<h2 id="4-mpa-multiple-page-application">4. MPA (Multiple Page Application)</h2>
<ul>
  <li>MPA는 SSR 방식을 사용하는 여러개의 Page로 구성된 Application이다. SPA와는 다르게 새로운 페이지를 요청할 때마다 정적 리소스를 가져와 전체 페이지를 다시 렌더링한다.</li>
</ul>

<p>[MPA 방식의 장점]</p>
<ul>
  <li>User가 보는 화면이 Web 크롤링 화면이랑 방식이 같아 SEO에 좋다.</li>
  <li>SPA 방식보다 써오던 방식과 역사가 길어 초보자들도 다양한 튜토리얼,해결법,프레임워크로 좋은 환경에서 제작할 수 있다.</li>
</ul>

<p>[MPA 방식의 단점]</p>
<ul>
  <li>다른 페이지 이동 시, 페이지를 새로 로딩하기에 UX가 좋지 않다.</li>
  <li>요청이 들어올 때마다 새로 패치하기에 속도가 느리다.</li>
  <li>프론트앤드와 백앤드가 확실하게 구분되어 있지 않고 연결성이 높아 서버쪽,클라이언트쪽 언어가 모두 필요하다.
<img src="https://velog.velcdn.com/images/wns450/post/13be25ec-96a5-47c7-bc85-6ad0acb5d01e/image.png" alt="image" title="정리사진" /></li>
</ul>

<h2 id="단어정리">단어정리</h2>
<ul>
  <li>렌더링(Rendering) : html.js 파일을 각 단계를 거쳐 User에게 보여주는 것으로 각 단계는 아래와 같다.
    <blockquote>
      <p>1) Parsing : 브라우저가 html 파일을 읽어 트리 자료형으로 해석하는 단계<br /> 
2) Style : parsing 단계에서 만들어진 트리에서 실제로 브라우저에 띄울 데이터를 트리로 자료형으로 정리해주는 단계<br />
3) Layout : Style 작업으로 만들어진 트리의 요소를 화면에 어떻게 배치할지 계산해주는 단계<br />
4) Paint : Layout 단계에서 계산된 값을 화면상에 실제 픽셀로 찍어주는 단계<br />
5) Composite : Paint 단계에서 생성된 레이어를 최종 합성해서 화면에 띄워주는 단계
<br /></p>
    </blockquote>
  </li>
  <li>인터렉션(Interation) : 단어의 뜻 그대로 Interface와 User가 서로 행동과 반응이 이어지 듯, 두 개체의 상호작용을 이야기 한다.</li>
  <li>검색엔진최적화(SEO:Search Engine Optimization) : 검색엔진 결과 페이지에서 사용자의 검색 결과에 대하여 웹 페이지의 상위 노출도를 높이는 작업이다.</li>
  <li>TTV(Time To View) : 사용자가 웹 사이트를 볼 수 있는 시간이다.</li>
  <li>TTI(Time To Interact) : 사용자가 웹에서 동적인 활동이 가능하게 되는 시간이다.</li>
  <li>UX(User Experience) : 단어의 뜻 그래도 사용자의 경험이란 뜻으로 UI에서 느끼는 사용자들의 느낌, 태도, 행동 등을 말하며 UX가 좋을 수록 사용자는 UI에서 편안함을 느낀다 할 수 있따.</li>
</ul>]]></content><author><name>Armando Maynez</name></author><category term="opinion" /><category term="front-end" /><category term="basic" /><summary type="html"><![CDATA[CSR/SSR,MAP/SPA이 각각 무엇인지 그 차이가 뭔지 알아보자.]]></summary></entry><entry><title type="html">Interface란?</title><link href="http://localhost:4000/Interface.html" rel="alternate" type="text/html" title="Interface란?" /><published>2023-04-16T00:00:00+09:00</published><updated>2023-04-16T00:00:00+09:00</updated><id>http://localhost:4000/Interface</id><content type="html" xml:base="http://localhost:4000/Interface.html"><![CDATA[<hr />
<h2 id="1-interface란">1. Interface란?</h2>
<ul>
  <li>인터페이스(interface)란 서로 다른 두 개 이상의 독립된 시스템 또는 장치 간의 정보를 교환하는 <a href="#단어정리">공유경계(shared boundary)</a>를 말한다.</li>
  <li>컴퓨터와 사용자의 간에 통신이 가능하도록 하는 프로그램 또는 장치를 말한다.</li>
  <li>이러한 interface는 상호작용하는 대상 관계에 따라 크게 하드웨어 인터페이스, 소프트웨어 인터페이스, 사용자 인터페이스로 3가지로 나눌 수 있습니다.</li>
</ul>

<hr />
<h2 id="2-하드웨어-인터페이스-hardware-interface">2. 하드웨어 인터페이스 (Hardware Interface)</h2>
<ul>
  <li>상호작용하는 대상이 물리적인 기기인 인터페이스로 서로 다른 물리적인 기기를 연결해주는 역할을 한다.</li>
  <li>대표적인 하드웨어 인터페이스로는 <b>USB Interface</b>가 있다.</li>
  <li>USB는 ‘Universal Serial Bus’의 약자로 컴퓨터와 주변 장치를 연결하기 위해 1996년에 만들어진 통일된 연결방법으로 대표적인 하드웨어 인터페이스이다.</li>
</ul>

<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FTzZyj%2FbtqUM9hdCm0%2FuiBwRgXts1ewIdv5s5fUG1%2Fimg.png" alt="Hartware Interface" title="하드웨어 인터페이스" /></p>

<hr />
<h2 id="3-소프트웨어-인터페이스-software-interface">3. 소프트웨어 인터페이스 (Software Interface)</h2>
<ul>
  <li>상호작용하는 대상이 소프트웨어와 하드웨어로 이를 소프트웨어를 통하여 하드웨어의 동작을 지시하고 제어할 수 있도록 연결해주는 역할을 한다.</li>
  <li>대표적인 소프트웨어 인터페이스로는 <b>API</b>가 있다.</li>
  <li>API는 ‘Application Programming Interface’의 약자로 응용 프로그램 간에 호환이 가능하도록 상호 작용하는 방식을 정해둔 대표적인 소프트웨어 인터페이스이다.</li>
</ul>

<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbMG3RQ%2FbtqUMatVnP5%2FIcOnawRkZ9lr9nQ2Jp7uB0%2Fimg.png" alt="Software Interface" title="소프트웨어 인터페이스" /></p>

<hr />
<h2 id="4-사용자-인터페이스-user-interface">4. 사용자 인터페이스 (User Interface)</h2>
<ul>
  <li>상호작용하는 대상이 사람과 컴퓨터로 사용자가 컴퓨터를 제어할 수 있도록 연결해주는 역할을 한다.</li>
  <li>초기에는 CLI(Command Line Interface)라는 인터페이스를 통하여 사용자가 컴퓨터가 수행할 작업을 지시하고 제어했으나 사용하기 까다로워 사용자가 사용하기에 어렵지 않은 대표적인 사용자 인터페이스인 <b>GUI</b>를 만들었다.</li>
  <li>GUI는 ‘Graphical User Interface’의 약자로 그래픽 요소를 사용해 컴퓨터에게 보내는 명령을 직관적으로 알기 쉽게 아이콘 등으로 나타낸 대표적인 사용자 인터페이스이다.</li>
</ul>

<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbQkIFN%2FbtqUzuU3ogu%2FnHCg9G9BDJ5ueKfCUn9eP1%2Fimg.png" alt="User Interface" title="사용자 인터페이스" /></p>

<hr />
<h2 id="5-interface-마무리">5. Interface 마무리</h2>
<ul>
  <li>본 게시글은 위와 같이 Interface란 무엇인지에 관하여 사전적 의미를 정리했다. 하지만 앞으로 front-end 개발을 위해 정의 뿐만 아니라 Interface를 어떻게 구성해야 하는지 알고 넘어갈 필요가 있다.</li>
  <li>Interface의 중요한 점은 직관성(Intution)이다. 다음 사진을 보고 어디에 사용하는 물건인지 생각해보자.
<img src="https://www.dhresource.com/0x0/f2/albu/g4/M01/5B/B8/rBVaEFnA4CCAPRiYAAC8hVrHylQ515.jpg" alt="PopcornMachine" title="PopcornMachine" /></li>
  <li>사진을 보았을 땐 폭탄이 터질 것 같은 모습에 압력 장치, 잠금 장치도 보이는 흡사 무시무시한 무기를 저장할 것 같은 그런 기계로 보인다. 하지만 놀랍게도 이는 그냥 팝콘 튀기는 장치이다. 대부분의 사람들은 팝콘을 알지만 저 물건을 맞춘 사람은 소수일 것이다.</li>
  <li>이는 저 기계가 사용자가 사용하기엔 직관성이 떨어지는 인터페이스들을 가지고 있기 때문이다. 이번엔 다른 예시를 보자.
<img src="https://ditoday.com/wp-content/uploads/2019/04/1904-digital-insight-know-how-user.x-ui-03.jpg" alt="다리미" title="다리미" /></li>
  <li>이 사진을 보자마자 여러분은 이것이 어디에 사용하는 물건인지 바로 알아차렸을 것이라 생각한다. 두꺼운 철판과 손잡이 그리고 버튼들 이 인터페이스의 구성으로 우리는 하드웨어의 정체성을 바로 파악할 수 있었다.</li>
  <li>이처럼 인터페이스는 상호작용의 경계면의 역할 뿐이 아니라 존재 자체로 우리에게 정보를 전달 해주는 역할도 한다고 볼 수 있다.</li>
  <li>위와 같은 예시로 Interface를 통하여 생각보다 많은 정보를 사용자에게 줄 수 있다는 점에서 다양한 시각으로 구성해야 한다는 점을 알 수 있다.</li>
</ul>

<hr />
<h2 id="단어정리">단어정리</h2>
<ul>
  <li>공유경계(shared boundary) : 특정기준으로 나누어진 사물 또는 공간을 공유하는 교집합의 빈 공간을 말한다. 즉, A와 B의 교집합이 공집합인 A와 B의 공유경계 S는 각각 A,B의 교집합 관계에서 공집합을 가지지 않음을 말한다.</li>
</ul>

<p><img src="./assets/img/posts/20230416/shared_boundary.jpeg" alt="shared boundary" /></p>]]></content><author><name>Armando Maynez</name></author><category term="opinion" /><category term="front-end" /><category term="basic" /><summary type="html"><![CDATA[Interface가 무엇인지, 종류와 Java언어로 기본적인 인터페이스 구성을 알아보자]]></summary></entry><entry><title type="html">Who owns the copyright for an AI generated creative work?</title><link href="http://localhost:4000/AI-and-intellectual-property.html" rel="alternate" type="text/html" title="Who owns the copyright for an AI generated creative work?" /><published>2021-04-20T00:00:00+09:00</published><updated>2021-04-20T00:00:00+09:00</updated><id>http://localhost:4000/AI-and-intellectual-property</id><content type="html" xml:base="http://localhost:4000/AI-and-intellectual-property.html"><![CDATA[<p>실험</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/tjzOzuKQhSM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<p>The project was created by <a href="https://overthebridge.org">Over the Bridge</a>, an organization dedicated to increase awareness on mental health and substance abuse in the music industry, trying to denormalize and remove the glamour around such illnesses within the music community.</p>

<p>They are using Google’s <a href="https://magenta.tensorflow.org">Magenta</a>, which is a neural network that precisely was conceived to explore the role of machine learning within the creative process. Magenta has been used to create a brand new “Beatles” song or even there was a band that <a href="https://arstechnica.com/gaming/2019/08/yachts-chain-tripping-is-a-new-landmark-for-ai-music-an-album-that-doesnt-suck/">used it to write a full album</a> in 2019.</p>

<p>So, while reading the article, my immediate thought was: who owns the copyright of these new songs?</p>

<p>Think about it, imagine one of this new songs becomes a massive hit with millions of youtube views and spotify streams, who can claim the royalties generated?</p>

<p>At first it seems quite simple, <em>Over the Bridge</em> should be the ones reaping the benefits, since they are the ones who had the idea, gathered the data and then fed the neural network to get the “work of art”. But in a second thought, didn’t the original artists provide the basis for the work the neural network generated? shouldn’t their state get credit? what about Google whose tool was used, should they get credit too?</p>

<p>Neural networks have been also used to create poetry, paintings and to write news articles, but how do they do it? A computer program developed for machine learning purposes is an algorithm that “learns” from data to make future decisions. When applied to art, music and literary works, machine learning algorithms are actually learning from some input data to generate a new piece of work, making independent decisions throughout the process to determine what the new work looks like. An important feature of this is that while programmers can set the parameters, the work is actually generated by the neural network itself, in a process akin to the thought processes of humans.</p>

<p>Now, creative works qualify for copyright protection if they are original, with most definitions of originality requiring a human author. Most jurisdictions, including <a href="https://www.wipo.int/wipolex/en/details.jsp?id=1319">Spain</a> and <a href="https://dejure.org/gesetze/UrhG/7.html">Germany</a>, specifically state that only works created by a human can be protected by <a href="https://www.wipo.int/copyright/en/">copyright</a>. In the United States, for example, <a href="https://copyright.gov/comp3/chap300/ch300-copyrightable-authorship.pdf">the Copyright Office has declared</a> that it will “register an original work of authorship, provided that the work was created by a human being.”</p>

<p>So as we currently stand, a human author is required to grant a copyright, which makes sense, there is no point of having a neural network be the beneficiary of royalties of a creative work (no bank would open an account for them anyways, lol).</p>

<p>I think amendments have to be made to the law to ensure that the person who undertook all the arrangements necessary for the work to be created by the neural network gets the credit but also we need to modify copyright law to ensure the original authors of the body of work used as data input to produce the new piece get their corresponding share of credit. This will get messy if someone uses for example the #1 song of every month in a decade to create the decade song, then there would be as many as 120 different artists to credit.</p>

<tweet>In a computer generated artistic work, both the person who undertook all the arrangements necessary for its creation as well as the original authors of the data input need to be credited.</tweet>

<p>There will still be some ambiguity as to who undertook the arrangements necessary, only the one who gathered the data and pressed the button to let the network learn, or does the person who created the neural network’s model also get credit? Shall we go all the way and say that even the programmer of the neural network gets some credit as well?</p>

<p>There are some countries, in particular the UK where some progress has been made to amend copyright laws to cater for computer generated works of art, but I believe this is one of those fields where technology will surpass our law making capacity and we will live under a grey area for a while, and maybe this is just what we need, by having these works ending up free for use by anyone in the world, perhaps a new model for remunerating creative work can be established, one that does not require commercial success to be necessary for artists to make a living, and thus they can become free to explore their art.</p>

<tweet>Perhaps a new model for remunerating creative work can be established, one that does not require commercial success to be necessary for artists to make a living.</tweet>

<p><img src="./assets/img/posts/20210420/post8-rembrandt2.jpg" alt="The next Rembrandt" />
<small><a href="https://www.jwt.com/en/work/thenextrembrandt">The Next Rembrandt</a> is a computer-generated 3-D–printed painting developed by a facial-recognition algorithm that scanned data from 346 known paintings by the Dutch painter in a process lasting 18 months. The portrait is based on 168,263 fragments from Rembrandt’s works.</small></p>]]></content><author><name>Armando Maynez</name></author><category term="opinion" /><category term="copyright" /><category term="creativity" /><category term="neural networks" /><category term="machine learning" /><category term="artificial intelligence" /><summary type="html"><![CDATA[As neural networks are used more and more in the creative process, text, images and even music are now created by AI, but who owns the copyright for those works?]]></summary></entry></feed>