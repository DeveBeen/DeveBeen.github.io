[
  
    {
      "title"       : "DOM이란?",
      "category"    : "opinion",
      "tags"        : "front-end, dom, basic",
      "url"         : "./DOM.html",
      "date"        : "2023-05-07 00:00:00 +0900",
      "description" : "DOM이란 무엇인지 알아보고 이해하자.",
      "content"     : "1. DOM이란? DOM(Document Object Model)은 말 해석 그대로 문서 객체 모델을 말하며, 웹 브라우저가 hml 파일을 받아 렌더링하는 과정에서 문서를 해석할 때 사용된다. 브라우저는 렌더링 할 때 xml, html 파일을 트리 형식으로 태그별 객체화하여 정리하여 렌더링을 한다. 보통 DOM의 가장 상위 태그는 html이다.2. DOM을 왜 쓰는가? DOM은 html을 위한 api라 할 수 있으며 html을 탐색할 때 사용되고 html의 구조를 바꿀 수도 있도록 한다. 이러한 작업을 해주는 언어가 JavaScript라 할 수 있다. 즉, JavaScript를 이용하여 DOM이란 장소에서 트리 형태로 저장된 html을 수정할 수 있다. 중요한 것은 DOM은 HTML이랑 같은 것이 아니다!!&lt;html&gt; &lt;body&gt; &lt;p&gt;Hello Would&lt;/p&gt; &lt;div&gt;&lt;img src=\"example.png\" /&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 위 html 코드는 아래와 같은 DOM 트리 구조를 가진다 할 수 있다.3. DOM 활용 렌더링 브라우저는 DOM을 이용하여 어떻게 화면을 렌더링할까? 브라우저는 html 태그를 파싱해 돔 트리를 구성하며 동시에 브라우저는 스타일 시트에서 css를 파싱하여 스타일 규칙들을 만들어낸다. 위에서 언급한 돔 트리와 스타일 규칙 두 가지 합쳐서 렌더 트리를 만들어낸다.[DOM의 문제점] DOM은 업데이트 하는데 너무 많은 비용이 드는데 일반적인 앱에는 DOM을 구성하는 수천개 이상의 노드가 있을 수도 있기에 DOM을 업데이트하는데 많은 비용이 들 수도 있다."
    } ,
  
    {
      "title"       : "PWA란?",
      "category"    : "opinion",
      "tags"        : "front-end, pwa, basic",
      "url"         : "./PWA.html",
      "date"        : "2023-05-07 00:00:00 +0900",
      "description" : "PWA가 무엇인지 알아보고 이해하자.",
      "content"     : "1. PWA(Progressive Web Apps)? PWA란 모바일 사이트에서 네이티브 앱과 같은 UX를 제공하는 기술을 말한다. 즉, 모바일 사이트에서 앱을 사용한 것과 같이 홈 화면에 아이콘 등을 배치하고 오프라인 열람 등을 제공하는 기술이다.2. PWA의 특징 반응형 디자인 : PWA는 네이티브 앱과 같이 기본적으로 반응형 디자인을 염두해 개발한다. 반응형 디자인은 다양한 화면 크기와 방향에 맞게 레이아웃과 콘텐츠를 자동으로 조정하여 스마트폰, 태블릿 및 데스크탑과 같은 다양한 장치에서 일관된 사용자 경험을 보장한다. 연결독립성 : PWA는 기본 브라우저 스레드와 별도로 백그라운드에서 실행되는 서비스워커를 사용한다. 앱처럼 사용 : PWA는 사용자의 장치에 설치되어 일반 앱처럼 아이콘 등을 배치할 수 있으며 기존 URL 바를 보여주는 부분이 없이 실행이 가능해 앱처럼 사용가능하다. 푸시 알림 : PWA는 앱이 활성화 되지 않아도 사용자에게 푸시 알림을 보낼 수 있다. 백그라운드 동기화 : PWA는 백그라운드에서도 최신상태로 유지할 수 있다. 보안 컨텍스트 : PWA는 HTTPS를 통해 제공되어 사용자와 앱간의 보안 연결을 보장해야 한다. 검색 : PWA는 웹이기 때문에 앱스토어에서 앱을 설치할 필요 없이 검색 엔진 통해 검색하고 URL을 통해 공유할 수 있다.[PWA의 장점] 플렛폼과 호환성 : PWA는 최신 웹 브라우저가 있는 모든 플랫폼에서 실행할 수 있어 Andriod, iOS 등 다양한 플랫폼에 대해 호환성이 좋아 별도 앱을 개발할 필요가 없다. 업데이트 속도 : PWA는 서버에서 직접 업데이트 할 수 있어 사용자가 앱에서 수동으로 업데이트 하지 않아도 된디. 오프라인 엑세스 : 서비스 워커는 PWA가 오프라인에서도 작업할 수 있도록한다. 앱과 같은 UX : PWA는 장치의 홈 화면에 설치할 수 있으며 푸시 알림과 같은 기능을 지원하여 기본 앱과 유사한 사용자 경험을 제공한다. 개발 및 유지비용 절감 : PWA는 웹 기술을 사용하므로 개발자는 기존 웹기술을 활용하고 여러 플랫폼에 대한 단일 코드베이스를 유지 관리하여 개발 및 유지 관리 비용을 줄일 수 있다.[PWA의 단점] 제한된 기능 : PWA는 고급 카메라 제어 또는 특정 센서와 같은 모든 기본 장치 및 API에 액세스하지 못할 수 있다. 가시성 감소 : PWA는 기존 앱들과는 다르게 앱스토어에서 나열되어 있지 않아 가시성이 떨어진다. 일관성 부족 : 최신 브라우저는 PWA를 지원하지만 다양한 플렛폼 간에 구현이 다를 수 있다.3. 서비스워커 서비스워커란 브라우저가 백그라운드에서 실행하는 웹페이지랑은 다르게 별개로 작동하는 스크립트로 오프라인 문제를 해결하기 위해서 만들어졌다. 서비스 워커는 개발자에게 오프라인 환경을 통제할 수 있는 권한을 부여하여 오프라인 환경에서 캐시와의 상호작용, 백그라운드 동기화, 푸시알림 등의 기능을 가능하게 했다.[서비스워커 특징] 서비스워커는 사용자가 요청해야 동작하며, 할 일을 모두 마쳐야지 종료된다. 서비스워커는 웹페이지 밖에서 동작하기 때문에 웹브라우저의 열고 닫힘과 무관하게 작동한다. 웹페이지 밖에서 동작하기 때문에 DOM요소에 접근할 수 있다."
    } ,
  
    {
      "title"       : "Js Hoisting이란?",
      "category"    : "opinion",
      "tags"        : "front-end, javascript, hoisting, basic",
      "url"         : "./JsHosting.html",
      "date"        : "2023-05-07 00:00:00 +0900",
      "description" : "Js Hoisting이란 무엇인지 알아보고 이해하자.",
      "content"     : "1. 호이스팅 (Hoisting) 호이스팅은 코드가 실행하기 전 변수선언/함수선언이 해당 스코프의 최상단으로 끌어 올려진 것만 같은 현상을 말한다. 이에 개발자는 코드를 어디에 작성해도 실행 시 코드가 최상단으로 끌어올려저서 실행된다. 자바스크립트 엔진은 코드를 실행하기 전에 실행 가능한 코드를 형상화하고 구분하는 과정(실행 컨텍스트 과정 중 하나)을 거치는데 이때, 모든 선언을 스코프에 등록하기 때문에 이때 변수는 초기화가 되진 않았지만 생성은 되어있는 상태가 되어 이러한 현상이 발생한다.2. 함수의 호이스팅 자바스크립트에서는 함수를 정의하는 방법으로 아래와 같이 함수 표현식과 함수 선언식이 있다.// 함수 선언식function add(x, y) { return x + y;}// 함수 표현식const add = function(x, y) { return x + y;}; 기본적으로 둘 다 함수를 만드는 동일한 기능을 하지만, 함수 표현식 같은 경우는 함수를 변수에 할당하므로 유연성이 높으며, 호이스팅이 강제로 진행되지 않아 개발자에게 혼동을 주지 않는다.console.log(add(2, 3)); function add(x, y) { return x + y; } console.log(add(3, 4)); 위와 같은 코드는 함수 선언식을 사용한 것으로 함수를 뒤늦게 생성하였더라도 함수 호이스팅이 발생하여 5와 7이 출력된다. 이러한 구조는 함수를 선언하기 전에 함수를 선언한 것처럼 보여지기에 개발하는데 혼동을 줄 수 있어 함수 선언식이 아닌 함수 표현식을 권장한다.console.log(add(2, 3));var add = function (x, y) { return x + y; } console.log(add(3, 4)); 위 코드는 함수 표현식을 사용하혀 정의한 것으로 함수를 정의하기 전에 add(2,3)을 호출했기 때문에 에러가 발생한다. 그 후 함수를 정의한 후에 실행한 add(3, 4)는 정상적으로 실행되는데 이는 호이스팅이 일어나지 않았기 때문이다.3. 변수 호이스팅 함수 뿐만 아니라 변수에서도 위와 같은 호이스팅 현상이 일어나는데 이는 var을 사용해서 정의했을 때를 이야기한다.var globalNum = 10;function printNum() { document.write(globalNum); var globalNum = 20; document.write(globalNum);}printNum();// undefined// 20 처음에 전역변수로 값을 선언했음에도 첫 변수 호출값은 undefined가 나왔다. 이는 변수 호이스팅이 일어나 아래 코드와 같이 선언된 것처럼 변하기 때문이다.var globalNum = 10;function printNum() { var globalNum; // 함수 호이스팅에 의해 변수의 선언 부분이 이동 document.write(globalNum); globalNum = 20; document.write(globalNum);}printNum(); 이러한 특징 때문에 코드의 가독성을 해치거나, 예상치 못한 동작을 일으키기도 하므로 변수를 선언할때는 var 키워드는 사용하지 않는 것을 권장하며 ES6의 let 이나 const 키워드를 사용하는 것을 강력히 권장한다. let, const로 변수를 선언하면 블록 스코프를 가지며 호이스팅이 발생하지 않기 때문이다.단어정리블록 스코프 : 주어진 코드 불록 안에서만 사용할 수 있도록 외부 코드와 단절 시키는 영역이다."
    } ,
  
    {
      "title"       : "CORS란?",
      "category"    : "opinion",
      "tags"        : "front-end, cors, basic",
      "url"         : "./CORS.html",
      "date"        : "2023-05-07 00:00:00 +0900",
      "description" : "CORS가 무엇인지 알아보고 해결 방안을 생각해보자.",
      "content"     : "1. CORS란? CORS(Cross-Origin Resource Sharing)는 영단어 그대로 해석하면 “교차 출처 리소스 공유”로 추가 HTTP 헤더를 사용하여, 한 출처에서 실행 중인 웹 애플리케이션이 다른 출처의 선택한 자원에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 체제이다. 즉, 한 출처(origin)에서 실행되고 있는 웹 애플리케이션이 다른 출처(cross-origin)에 원하는 리소스 접근권한을 알려주는 메커니즘이다.2. 정책 HTTP 요청에 대해서 HTML은 Cross-Origin 정책을 따르기 때문에 기본적으로 Cross-Origin 요청이 가능하다. 예를들어 HTML에서 link 태그에서 다른 origin의 css 등의 리소스에 접근하는 것이 가능하고, img 태그에서 다른 jpg, png 등의 리소스에 접근하는 것이 가능하다. 하지만 예외적으로 script 태그 내 HTTP 요청에 대하여는 보안상 이유로 Same-Origin 정책을 따르기에 Cross-Origin 요청이 불가능하다.3. 사용처? 보안상 문제? CORS는 그러면 보안상의 문제는 없는지?, 왜 사용하는지? 라는 의문이 들 수도 있다고 생각한다. 그러기 위해서는 먼저 SOP(동일 출처 정책)을 이해해야 한다. SPO는 브라우저의 보안상 만들어졌는다. 우리 브라우저는 능동적 공격, 수동적 공격을 받을 수 있다. 이때 서로 다른 사이트 간에 통신이 이루어지는 부분에서 공격을 받을 수 있고 이는 보안 문제로 이어지기에 웹 브라우저는 SPO라는 정책으로 다른 사이트 간에 통신인 교차 출처를 막아 보안 문제를 해결했다. 이러한 정책은 보안 문제는 해결했지만 결국 교차 출처가 불가능해지기에 사이트 간 데이터 공유가 어려워져 HTTP 요청을 통해 교차 출처를 통해 데이터 공유가 가능하게 하는 CORS를 사용하기 시작했다.4. CORS 시나리오 CORS라는 정책은 강력하기 때문에 CORS 이슈가 많이 등장할 수 밖에 없다. 즉, 안전성은 보장 받았지만 그만큼 까다로워 정책 위반 ERROR가 많이 발생한다는 것이다. 이를 해결하기 위해 우리는 CORS의 동작 시나리오를 살펴볼 필요가 있다. CORS의 동작 시나리오는 아래와 같이 크게 3가지로 분류할 수 있다. 간단한 요청(Simple Request) : 특정 조건을 만족하는 요청의 경우에는 허락 없이도 다른 출처에 HTTP 요청을 보낼 수 있다. 사전 점검 요청 (Preflight Request) : 브라우저는 실제 요청 전 preflight라는 HTTP 사전 요청을 진행 후 사전 요청이 가능하면 실제 HTTP 요청을 보낸다. 인증 정보를 포함한 요청(Credentialed Request) : 말 그대로 요청 시에 인증 정보를 보관한 헤더와 같이 요청하여 교차 출처가 가능하게 하는 요청 시나리오다.5. preflight가 왜 필요한가? CORS 문제를 인식하지 못하는 서버를 위해서 prefllight가 필요하다. 예를 들어 preflight가 없는 상황에서 교차 출처를 서버에 요청하면 서버는 CORS 설정이 없기 때문에 요구한 대로 정보를 그대로 가져온 후에 브라우저는 교차 출처 리소스라는 응답을 받기에 뒤늦게 브라우저가 Error를 띄워버려도 DB에서 이미 데이터가 증발했을 수도 있다.[Preflight가 없을 때][Preflight가 있을 때]단어정리 origin : 특정페이지에 접근할 때 사용되는 URL의 Scheme(프로토콜), host(도메인), 포트를 말한다. cross-origin : origin과 Scheme(프로토콜), host(도메인), 포트 중 하나라도 다른 URL을 말한다. 능동적 공격 : 해커가 브라우저에 직접 침투하여 행동하여 공격하는 것을 말한다. 수동적 공격 : 해커가 브라우저에 함정을 파둬 사용자 행동을 통해 공격하는 것을 말한다."
    } ,
  
    {
      "title"       : "Vue VS React",
      "category"    : "opinion",
      "tags"        : "front-end, vue, react, basic",
      "url"         : "./Vue-React.html",
      "date"        : "2023-05-07 00:00:00 +0900",
      "description" : "Vue VS React",
      "content"     : "1. Vue.js? 웹 화면을 만들기 위한 프론트엔드 라이브러리이자 점진적 프레임워크이다. 배우기 쉽게 만들어져 프로트엔드 개발에 있어 react와 함께 대중적인 오픈소스 js 프레임워크이다. SPA를 구축하는데 사용한다. MVVM패턴의 ViewModel에 해당하여, UI코드와 데이터제어 제어 로직을 분리했다.[구성요소] View(html DOM): 사용자에게 보이는 화면이다. Model(JS): 데이터를 담는 용기로 보통은 서버에서 가져온 javascript 객체를 저장한다. ViewModel: View와 Model의 중간 영역으로 DomListener와 DataBinding을 제공하는 영역이다. DOM: HTML 문서에 들어가는 요소(tag, class, attribute 등)의 정보를 담고 있는 트리 형태의 데이터이다. DOM Listener: DOM의 변경에 대한 즉각적으로 반응하여 특정 로직을 수행하는 장치이다. Data Binding: View에 표시되는 내용과 모델의 데이터를 동기화한다. Vue에서는 기본적으로 단방향 데이터바인딩으로 컴포넌트간 통신은 상위 컴포넌트에서 하위컴포넌트로 전달한다. Vue.js로 Hello World 출력 프로그램 짜기 &lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; new Vue({ el: \"#app\", data: { message: \"Vue.js - Hello World \", }, }); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;2. React? React는 javascript 라이브러리 중 하나로 사용자 인터페이스를 만들기 위해 사용한다. 페이스북(메타)와 개발자 및 기업들인 공동체에 의해 유지보수된다. Vue와 같이 SPA 개발 시 자주 사용된다.[React의 특징] Data Flow : 데이터의 흐름이 단방향성이다. Component 기반 구조 : React는 UI를 여러 컴포넌트로 쪼개진 독립된 컴포넌트를 조합하여 구현한다. Virtual Dom : Vue와 같이 데이터를 객체로 간주하는 트리구조의 형태를 가진다. Props : 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달하는 데이터로 자식 컴포넌트에서는 props를 변경 불가능하게 하는 특징을 가지고 있다. State : 컴포넌트 내부에 선언하여 값을 바꾸는 용도이며, 동적인 데이터를 다룰 때 사용된다. JSX : JS 문법을 확장시킨 것으로, 필수사용은 아니지만 UI 코드 작업 시 시각적으로 도움이 된다.3. 프레임워크? 라이브러리?[프레임워크?] 프레임워크(Framework)는 제어의 역전 개념이 적용된 소프트웨어의 기반 구조가 되는 대표적인 기술이다.[프레임워크의 특징] 특정 개념들의 추상화를 제공하는 재사용이 가능한 여러 클래스나 컴포넌트로 구성되어 있습니다. 추상적인 개념들이 문제를 해결하기 위해 같이 작업하는 방법을 정의합니다. 높은 수준에서 패턴들을 조작화 할 수 있습니다.[라이브러리?] 라이브러리(Library)는 활용가능한 도구들의 집합으로 개발자가 만들어둔 클래스를 호출하여 사용하는 방식으로 활용할 수 있다.[프레임워크 VS 라이브러리] 둘의 가장 큰 차이점은 제어 흐름에 대한 주도성이 누구에게 있냐에 있다. 프레임워크는 전체적인 흐름을 프레임워크가 가지고 있으며 사용자는 그 안에서 코드를 짜 넣는 반면 라이브러리는 사용자가 전체적인 흐름을 가지고 있어 사용자가 주도성을 가지고 있다. 간단하게 말해서 프레임워크는 누가 이미 만들어 놓은 틀에서 조금씩의 조작으로 만들어가는 기술이고, 라이브러리는 누군가가 만들어 놓은 또는 내가 만든 기능들을 호출하여 사용하면서 만들어가는 기술이다.4. Vue VS React? 위에 프레임워크와 라이브러리의 차이를 알았으니 Vue와 React의 사용처에 대한 조금은 왔을거라고 생각한다. 간단히 말해서 정해진 규칙대로 만들어진 프레임워크로 코드 통일성을 가지고 싶다면 Vue, 자유로운 코드 형식으로 자유도가 높은 코드를 사용하고 싶으면 React를 사용하면 된다. 위에 특성으로 Vue는 자유도가 떨어지고 Vue에서 제공해주는 문법으로만 코딩을 해야한다는 답답함이 있고, React는 개발자마다 코드가 다 달라 어떤 코딩을 해야하는지 감을 잡기 쉽지 않고 스타일을 통일할 때도 지속적인 커뮤니케이션 비용이 발생한다. 아직 감이 안온다면 아래 예시 내옹을 보자.[Vue를 사용해야 하는 상황] 프론트엔드 초보자 : 제어 흐름이 정해져있고 통일성이 있기에 초보자 입장에서 집입장벽이 낮고 쉽게 코드 통일하기 좋다. 개발자들의 코드를 많이 참고하는 사람 : 위에서 말한 것과 동일하게 Vue에서 정해진 규칙으로 코딩하기에 개발자들의 코드를 읽고 이해하기가 쉽다.[React를 사용해야 하는 상황] 프론트엔드 실력자 : 제어 흐름이 개발자에게 달려 있어 개발자의 생각으로 커스터마이징이 가능하며 높은 자유도를 가져 방대한 생태계가 존재한다. 규모가 큰 프로젝트 : 컴포넌트를 작은 단위로 쪼개 UI를 재사용하는 방면에서 코드의 직관성이 보장되기에 대규모 프로젝트를 진행할 때 적절하다.[둘의 시장 점유율] NPM trend에서 각 프레임워크의 다운로드 수치이다. 보는 것과 같이 자유도가 높은 면에서 이점이 많기에 당연히 react가 점유율이 높다는 것을 볼 수 있다.단어정리 Component : 독립적인 단위의 소프트웨어 모듈이다."
    } ,
  
    {
      "title"       : "Node.js 환경 VS 브라우저 환경",
      "category"    : "opinion",
      "tags"        : "front-end, node.js, browser, basic",
      "url"         : "./Environment.html",
      "date"        : "2023-05-07 00:00:00 +0900",
      "description" : "Node.js 환경 VS 브라우저 환경",
      "content"     : "1. Node.js란? Node.js는 V8 JavaScript 엔진으로 빌드되어 외부에 있는 JavaScript 코드를 실행하는 오픈소스 크로스 플렛폼 백엔드 런타임 환경이다. Node.js를 사용하여 개발자는 자바스크립트를 사용해서 명령줄 도구를 작성하고 서버측 스크립팅을 실행하여 페이지를 사용자의 웹 브라우저로 보내기 전에 동적 웹 페이지 컨텐츠를 생성할 수 있다. 즉, Node.js는 웹 어플리케이션을 통합하는 JS를 어디에서나 적용하고 쓸 수 있는 패러다임을 제공하는 서버측 스크립트, 클라이언트측 스크립트가 아닌 단일 프로그래밍 언어이다. Node.js는 이벤트 기반, 논 블로킹 I/O 모델이라는 특성으로 높은 처리 성능을 가지고 있다는 것이 특징이다.[이벤트 기반] 이벤트 기반은 이벤트 루프를 통해 이벤트 발생 시 미리 지정한 작업을 수행하는 방식을 이야기 한다. 이벤트 루프는 여러 이벤트가 동시 발생할 때 어떤 것을 우선 처리할 지 우선순위를 판단하는 사이클이다. Node.js는 이벤트가 종료될 때까지 이벤트 처리를 위한 작업을 반복한다.[논 블로킹 I/O 모델] 작업에는 두 가지 종류가 있는데 동시에 실행될 수 있는 작업과 동시에 실행될 수 없는 작업이있다. 이 중 논 블로킹은 이전 작업이 완료될 때까지 대기하지 않고 다음 작업을 수행하는 것을 말한다. Node.js는 싱글스레드 논 블로킹 방식으로 스레드는 하나지만 비동기식으로 이전작업의 완료를 기다리지 않고 다음 작업을 실행한다.2. 브라우저? 브라우저 환경을 알기 위해서 먼저 브라우저가 정확히 뭔지 알아야한다. 브라우저는 사전적 의미로는 인터넷상에서 웹에 연결 시켜주는 윈도우 기반의 소프트웨어이다. 쉽게 말해서 사용자인 우리가 웹에 접근하기 위한 도구를 브라우저라고 정의한다. 아래 사진과 같이 우리가 아는 브라우저는 여러 종류가 있다.3. Node.js, 브라우저 환경? 그렇다면 여기에 환경을 붙이면 정확히 무엇을 말하는 것이냐? 우리가 보통 개발 환경하면은 어떤 뜻으로 해석하는가? 그렇다 개발을 위해 셋팅하는 환경을 말한다. 위에 두가지도 직역하자면 Node.js 환경은 Node.js를 사용하기 위해 셋팅하는 환경, 브라우저 환경은 브라우저를 사용하기 위해 셋팅하는 환경을 말한다. 그러면 셋팅을 누가 하느냐? 개발환경은 보통 개발자가 언어를 채택하여 셋팅하는 방식이지만 위에 두 환경은 그 셋팅 주체가 JavaScript로 통일(약속)되어 있다.4. Node.js 환경과 브라우저 환경의 차이점 이제 확실하게 Node.js 환경이 뭔지, 브라우저 환경이 무엇인지 알았을 것이다. 그렇다면 이 둘의 차이점이 무엇인지 알아보자.[Node.js와 브라우저의 차이점] 존재목적 : 브라우저는 HTML,CSS,JS를 실행하여 사용자의 웹 화면에 랜더링하는 것이 주 목적이지만 Node.js는 서버 개발 환경을 제공하는 것이 주목적이다. 이에 둘 다 JS의 코어인 ECMAScript를 실행하나 이외 추가적인 API는 서로 호환되지 않는다. API : 브라우저는 시각적 표현이 필요한 것과 다르게 node.js는 필요가 없어 UI관련 API에도 차이가 있고, Node.js는 브라우저에서 사용가능한 window,document 객체가 없어 웹 플렛폼 API가 Node.js에는 호환되지 않는다. JS Engine : Node.js는 구글 Chrome 브라우저에서 사용하는 V8 엔진을 자바스크립트 실행 엔진으로 사용하지만 브라우저는 종류와 버전에 따라 엔진이 다양하다. 제어 : Node.js에서는 우리가 직접환경을 제어하여 버전 이동이 가능하지만 브라우저는 환경이 정해져 있기에 불가능하다. 이러한 차이점들로 Node.js는 컴퓨터의 깊은 부분을 제어하는 백엔드 기술에 최적화 되어 있음을 알 수 있다. 단어정리 V8 JavaScript 엔진 : 웹 브라우저를 만드는데 기반을 제공하는 오픈소스 자바스크립트 엔진으로 자바스크립트를 바이트 코드로 변환하여 읽어 웹 브라우저 내부의 속도 개선을 위해 만들어졌다. 크로스 플렛폼 : 컴퓨터 프로그램, 운영체제, 프로그래밍 언어 등 여러종류의 컴퓨터 플랫폼에서 동작할 수 있다는 뜻이다. 런타임 환경 : 런타임을 위해 시스템 적인 자원을 운영체제에게 요청하기 위해 엑세스할 수 있도록 해주는 환경을 말한다. ECMAScript : Ecma International이 ECMA-262 기술 규격에 따라 정의하고 있는 표준화된 스크립트 프로그래밍 언어를 말하며 자바 스크립트를 표준화하기 위해 사용된다."
    } ,
  
    {
      "title"       : "REST-API? RESTFUL-API?",
      "category"    : "opinion",
      "tags"        : "front-end, api, basic",
      "url"         : "./REST-API-RESTFUL-API.html",
      "date"        : "2023-05-06 00:00:00 +0900",
      "description" : "REST-API, RESTFUL-API가 무엇인지 알아보자.",
      "content"     : "1. REST란 무엇인가? REST(REpresentational State Transfer)는 정보를 주고 받는 방식에 있어 개발자들이 널리 쓰이는 일종의 형식으로 기본적으로 웹의 기존 기술과 HTTP 기술을 그대로 사용하기에 웹의 장점을 최대한 사용할 수 있는 아키텍쳐 스타일이다.[REST의 구성요소] URI : 서버의 존재하는 고유한 ID를 가진 자원으로 Client는 url을 이용하여 자원에 대한 조작을 Server에 요청한다. Method : HTTP 프로토콜의 Method를 사용한다. Representation of Resouce : Client가 Server와 주고 받는 데이터 형식으로 JSON, XML, TEXT, RSS 등이 있다.[REST의 특징] Server-Client 구조 : 자원을 요청하는 쪽이 Client, 자원을 가진 쪽이 Server로 서로의 역할을 확실히 하므로 의존성을 줄인다. Stateless(무상태) : Client의 context를 Server에 저장하지 않아 세션과 쿠키같은 context 정보를 신경쓰지 않아도 되기에 개발이 쉬워지고, Server는 각 요청이 모두 별개로 처리 되기에 일관성이 있다. 이때문에 서비스의 자유도가 높다. Cacheable(캐시 처리 가능) : 웹 표준 HTTP 프로토콜을 그대로 사용하기에 HTTP 프로토콜의 캐싱 기능을 사용할 수 있다. Layered System(계층구조) : Client는 REST API 서버만 호출하며 REST Server는 다층 계층으로 구성될 수 있다. Code-On-Demend : 서버로부터 스크립트를 받아서 클라이언트에서 실행한다. (무조건 충족할 필요는 없다.) 인터페이스 일관성 : URI로 지정한 자원에 대한 조작을 통일되고 한정적인 인터페이스로 수행하며 HTTP 표준 프로토콜에 따르는 모든 플랫폼에서 사용이 가능하다.[REST가 필요한 이유] 어플리케이션의 분리 통합을 위해서 필요하다. 다양한 클라이언트의 등장으로 다양한 브라우저와 모바일에서도 통신이 가능해야 한다.2. REST API? API는 인터넷상에서 데이터를 전송하고 이용할 수 있게 하는 소프트웨어 인터페이스이다. REST 개념과 합쳐서 REST API는 REST 기반 API이다. REST API를 사용하는 이유는 REST 기반으로 시스템을 분산해 확장성과 재사용성을 높여 유지보수와 운용을 편리하게 하기 위함이다. 따라서 REST API는 HTTP를 잘 사용하기위해, URI와 HTTP메소드를 사용해서, URI로 어떤 자원에 접근할 것인지, 메소드로 어떤 행위를 할것인지 표현하여 설계된 API를 말한다.[REST API의 특징] REST는 HTTP 표준을 기반으로 구현하므로, HTTP를 지원하는 프로그램 언어로 클라이언트, 서버를 구현할 수 있다. 각 요청이 어떤 동작이나 정보를 위한 것인지를 요청의 모습으로 추론이 가능하다.[REST API 설계 방법] URI은 정보의 자원을 표현 해야 한다. 자원에 대한 행위는 HTTP method로 표현하며 이는 URI에 포함되지 않는다.3. RESTFUL API? REST API는 아래와 같은 설계규칙이 있다.[설계규칙] URI는 명사를 사용한다. (Resource 이름은 동사가 아닌 명사) 슬래시(/)로 계층관계를 표현하며 해당 기호는 마지막에 오지 않는다. Underbar(_)를 사용하지 않고 hyphen(-)을 사용한다. URI는 소문자로만 구성한다. HTTP 응답상태 코드를 명시하여 잘못된 요청에 대한 피드백을 남겨야한다. URI에는 파일 확장자가 포함되지 않는다. RESTFUL API는 이러한 설계규칙을 잘 지켜서 설계된 REST API를 말한다.단어정리[HTTP 프로토콜의 Method] 이름 기능 GET Read : URL이 가진 정보를 검색하기 위해 서버에 요청한다. POST Create : 클라이언트에서 서버로 전달하려는 정보를 보낸다. PUT Update : 데이터 전부 내용을 갱신할 때 주로 사용 PATCH Update : 데이터 일부 내용을 갱신할 때 주로 사용 DELETE Delete : 정보를 삭제하는 메소드이나 보안 문제로 대부분 비활성화 RSS : Real Simple Syndication의 약자로 뉴스나 블로그에서 주로 사용하는 콘텐츠 표현 파일형식이다."
    } ,
  
    {
      "title"       : "Session? Cookie?",
      "category"    : "opinion",
      "tags"        : "front-end, network, basic",
      "url"         : "./Session-Cookie.html",
      "date"        : "2023-05-04 00:00:00 +0900",
      "description" : "세션과 쿠키 그리고 로컬스토리지가 무엇인지 알아보자.",
      "content"     : "1. 쿠키(Cookie)란? 쿠키는 클라이언트(브라우저) 로컬에 저장되는 키와 값이 들어있는 작은 데이터 파일로 클라이언트의 상태 정보를 로컬에 저장했다가 참조한다. 사용자 인증이 유효한 시간을 명시할 수 있고, 유효 시간이 정해지면 브라우저가 종료되어도 인증이 유지된다는 특징이 있다. 하나의 쿠기값은 4KB로 클라이언트에 300개까지 쿠키를 저장가능하며 도메인당 20개의 값만 가질 수 있다. Response Header에 Set-Cookie 속성을 사용하면 클라이언트에 쿠키를 만들 수 있습니다. 쿠키는 사용자가 따로 요청하지 않아도 브라우저가 Request시에 Request Header를 넣어서 자동으로 서버에 전송합니다.[쿠키를 사용하는 이유] 세션관리(Session Management) : 서버에 저장해야 할 정보를 관리한다. 개인화(Personalization) : 사용자 선호, 테마 등을 세팅한다. 트래킹(Tracking) : 사용자의 행동을 기록하고 분석한다.[쿠키의 구성요소] 이름 : 쿠키를 구별하는데 사용되는 이름 값 : 쿠키의 이름과 관련된 값 유효시간 : 쿠키의 유지시간 도메인 : 쿠키를 전송할 도메인 경로 : 쿠키를 전송할 경로 보안 : 보안 연결 설정 HttpOnly : HTTP 외 다른 통신 사용 가능[쿠키의 동작순서]1) 클라이언트가 페이지를 요청2) 서버에서 쿠키를 생성하여 HTTP 헤더에 쿠키를 포함하여 응답3) 브라우저가 종료되어도 쿠키 만료시간이 있다면 클러이언트에서 보관4) 같은 요청 시 HTTP 헤더에 쿠키를 포함시켜 보냄5) 서버에서 쿠키를 읽어 이전 상태 정보를 변경 할 필요가 있을 때 쿠키를 업데이트 하여 변경된 쿠키를 HTTP 헤더에 포함시켜 응답[쿠키의 단점] 쿠키에 대한 정보를 매번 헤더에 추가하여 보내기에 트래픽을 많이 발생시킨다. 쿠기의 대한 정보가 유출되면 보안 문제도 발생하기에 보안이 취약하다.2. 세션(Session)이란? 세션은 쿠키를 기반하고 있지만 사용자 정보 파일을 브라우저에 저장하는 쿠키와 달리 서버 측에서 관리하는 데이터 파일이다. 서버에서는 클라이언트를 구분하기 위해 세션 ID를 부여하며 웹 브라우저가 서버에 접속해서 브라우저를 종료할 때까지 인증상태를 유지하고 접속시간에 제한을 두어 일정 시간 응답이 없다면 정보가 유지되지 않게 설정이 가능하다. 클라이언트가 Request를 보내면, 해당 서버의 엔진이 클라이언트에게 유일한 ID를 부여하는 데 이것이 세션 ID입니다.[세션의 동작순서]1) 클라이언트가 서버에 Resource를 요청합니다.2) 서버에서는 HTTP Request를 통해 쿠키에서 세션 ID를 확인을 한 후에 없으면 쿠키를 셋팅하여 새로 발행한 세션 ID 보냅니다.3) 클라이언트는 HTTP Request 헤더에 세션 ID를 포함하여 원하는 Resource를 요청을 합니다.4) 서버는 세션 ID를 통해 해당 세션을 찾아 클라이언트 상태 정보를 유지하며 적절한 응답을 합니다.[세션의 장점] 신뢰할 수 있는 유저인지 서버에서 추가로 확인 가능 (최초 접속 때를 제외하고 세션ID만 사용) 저장 개수나 용량 제한 없어 서버 용량이 충분하다면 큰 용량을 허용한다. 데이터를 Hash Table에 저장. 한 번에 많은 정보를 하나의 세션 객체에 저장 가능 세션 ID만 보내므로, 세션의 크기가 커도 네트워크 부하가 거의 없다. 서버에 저장되므로 클라이언트의 웹브라우저에 의존하지 않아도 된다.[세션의 단점] 사용자에 대한 정보를 서버에 두기 때문에 사용자가 많아질수록 서버 메모리를 많이 차지한다.3. 쿠키 or 세션? 세션은 결국 쿠키를 사용한 것이기에 쿠키와 세션은 비슷한 역할을 하며, 동작원리도 비슷하다. 둘이 비슷한 역할을 하나 쿠키는 서버 자원을 전혀 사용하지 않고, 세션은 서버의 자원을 사용해 사용자의 정보가 저장되는 위치가 다르다는 차이점이 있다. 보안 면에서 세션이 더 우수하며, 요청 속도는 쿠키가 세션보다 더 빠릅니다. 그 이유는 세션은 서버의 처리가 필요하기 때문입니다.보안면에서 쿠키는 클라이언트 로컬에 저장되기에 request에서 스니핑을 당할 우려가 있어 보안에 취약하지만 세션은 세션 ID만 저장하고 서버에서 그것을 구분해서 처리하기에 보안성이 좋다.4. 로컬스토리지(LocalStorage) LocalStorage는 Local:헌지의,Storage:저장소로 말 그대로 현지의 저장소. 즉, 사용자의 로컬에 존재하는 저장소를 말한다. 로컬 스토리지는 만료시간이 존재하지 않아 페이지나 브러우저를 닫아도 반 영구적으로 유지되는 저장소이다. 로컬 스토리지는 key와 value 형태로 이루어진다.[로컬 스토리지 메소드,속성] 이름 구분 쿠키 setitem(key,value) 메서드 해당 키 값으로 데이터를 저장 getitem(key) 메서드 해당 키 값의 이름을 가진 데이터를 가져옴 removeitem 메서드 해당 키 값의 이름을 가진 데이터를 삭제 key(index) 메서드 해당 인덱스를 가진 키 값을 가져옴 clear() 메서드 모든 데이터를 삭제 length 속성 저장된 데이터 수를 가져옴 단어정리 Response Header : 위치 또는 서버 자체에 대한 정보(이름, 버전 등)와 같이 응답에 대한 부가적인 정보를 갖는 헤더이다. Request Header : HTTP 요청에서 사용되지만 메시지의 컨텐츠와는 관련이 없는 헤더이다. Hash Table : 해시 테이블은 (Key, Value)로 데이터를 저장하는 자료구조 중 하나로 빠르게 데이터를 검색할 수 있는 자료구조이다. 스니핑 : 네트워크 트래픽을 도청하는 과정을 말한다."
    } ,
  
    {
      "title"       : "Javascript",
      "category"    : "opinion",
      "tags"        : "front-end, javascript, basic",
      "url"         : "./Java-Basic.html",
      "date"        : "2023-04-29 00:00:00 +0900",
      "description" : "JavaScript가 무엇인지 알아보고 기초 문법에 대해 알아보자.",
      "content"     : "1. JavaScript란? js는 웹 페이지의 생동감을 불어 넣기 위해 만들어진 프로그래밍 언어이다. HTML과 CSS언어와는 다르게 C언어, java와 같은 일반 프로그래밍 언어와 비슷하게 생겼으며 HTML,CSS,JS를 이용하는 프론트엔드 초보자에게는 어려운 부분이다. js는 객체기반의 스크립트 언어로 기본적으로 웹 브라우저에서 해석되는 인터ㅡ리터 언어이다. Node.js와 같은 프레임 워크를 사용해 서버 프로그래밍도 가능하다.[JS의 특징] 동적이며 타입을 명시할 필요가 없는 인터프리터 언어이다. 객체지향 프로그래밍과 함수형 프로그래밍을 모두 표현 가능하다. HTML의 내용, 속성, 스타일을 변경할 수 있다."
    } ,
  
    {
      "title"       : "Git,Github?",
      "category"    : "opinion",
      "tags"        : "front-end, git, basic",
      "url"         : "./Git-Github.html",
      "date"        : "2023-04-29 00:00:00 +0900",
      "description" : "Git,Github가 무엇인지 알아보고, Git Flow 개념을 이해해보자.",
      "content"     : "1. Github,Git이란? git이란 Distributed version control system이다. 즉, 직역하면 분산 버전 관리 시스템으로 분산해서 버전을 관리(변화,변경)를 하는 시스템을 말한다. github라는 Web Service의 주요 기능인 원격 저장소 역할을 한다. GoogleDrive 같은 원격 저장소와는 버전으로 관리 되어 하위 버전 이동 또는 버전 업데이트가 자유롭다. github는 이러한 git을 사용하여 현업과 프로젝트 버전관리등의 유용한 기능을 하는 개발자의 커뮤니티이다.2. 그래서 버전 관리를 왜 하는데? 다양한 이유가 있지만 먼저 간단하게 시각적으로 보자면 아래와 같은 상황을 방지하기 위함이다. “조별과제_김원빈.pptx”“조별과제_김원빈_성준수정.pptx”“조별과제_김원빈_성준수정_최종.pptx”“조별과제_김원빈_성준수정_최종_의최종.pptx”“조별과제_김원빈_성준수정_최종_의최종_을철현수정.pptx”“조별과제_김원빈_성준수정_최종_의최종_을철현수정_최종.pptx” . . . 위와 같은 방식을 버전 관리라고 한다. 즉, 과거 파일을 백업해두는 방법이다. 위 같은 방식도 작업하기엔 문제도 없고 백업 기능도 있기에 괜찮아 보일 수 있으나 큰 문제가 있다. 위 파일은 조별과제이다. 개인이 작업하는게 아니라 조원들이 관리하다가 너도나도 파일을 수정한다면 파일 백업 의미가 없어져 버린다. 아래와 같은 이유로 깃허브를 사용한다고 할 수 있다.[팀 프로젝트 버전 관리의 문제]1) 여러 개의 파일 버전을 일관되게 관리하기 힘들다.(누가 가장 최신 파일을 가지고 있는지 모른다.2) 누가/무엇을/어떻게 변경하였는지 기록,확인,공유가 어렵다.3) 서로의 변경 내역을 덮어씌우거나 지워버려 오류가 발생할 수 있다.4) 변경 전 버전을 특정할 수 없으므로 내용을 이전 상태로 돌리기도 어렵다.3. Git-Flow 개념 이해하기 git-flow는 과거 Vincent Driessen이라는 사람의 블로그를 통해 알려진 Git 개발 방식의 방법론으로 기능적인 것이 아닌 약속의 의미를 가지고 있는 방법론이다. git-flow는 아래와 같이 5가지 브랜치(branch)로 나뉜다.[Git-Flow 전략] master : 기준인 역할을 하는 브랜치로 제품을 배포하는 최종 브랜치이다. develop : 개발할 때의 메인 브랜치로. 구현해야할 기능이 발생하면 feature 브랜치를 생성 및 개발, 구현 완료 후 develop 브랜치로 병합한다. 다음 배포 버전까지 개발 완료 후 QA Test를위해 release 브랜치로 머지(merge)된다 feature : 이슈 및 기능을 구현하기 위해 생성하는 브랜치로 develop 브랜치에서 생성한다. 기능 구현이 완료되면 develop 브랜치에 머지하고 feature 브랜치는 삭제한다. release : develop에 저장되어 QA를 진행하여 통과 시 master 브랜치에 머지하는 QA 진행 브랜치이다. hotfix : 게임을 한 사람들에게는 익숙한 이름의 브랜치로 배포 후 release 브랜치에서 발견 못한 버그가 발생하여 긴급한 수정이 필요할 때 생성하는 브랜치이다. master에서 생성하고 수정 후 master, develop 브랜치에 머지하고 hotfix 브렌치는 삭제한다.4. Git-Flow 상세 위에 git-flow에 사용되는 브랜치를 알아봤다. 하지만 저렇게 정의를 해두는 것은 알겠지만 정의만 보고 흐름이 잘 보이지 않는다. 그렇다면 각 브랜치의 모습을 하나씩 보며 흐름을 이해해보자.[master branch] 배포가능한 상태를 관리하는 브랜치[develop branch] 다음 버전을 개발하는 브랜치 평소 개발 시 기준이 되는 개발 브랜치이다.[feature branch] 기능을 개발하는 브랜치로 develop 브랜치에서 뻗어나와 좀 더 세부적으로 개발하기 위한 역할을 하는 보조 브랜치이다. feature 브랜치는 기능을 완성할 때까지 유지하며, 완료되면 develop 브랜치에 머지한다. 물론 기능이 별로다 싶으면 버린다. (develop에 머지하지 않았으니 영향을 미치지 않는다. 그러니 확실하다 싶으면 머지하는 것이 중요하다.)[release branch] 필터 역할을 하는 브랜치로 develop에서 master로 머지하기 전에 최종 수정을 위해 QA하는 브랜치이다. 중요한 것은 release 브랜치에서 수정된 사항이 있으면 develop 브랜치에도 머지를 시켜줘야 다음 버전 개발에 꼬이지 않는다.[hotfix branch] 배포 버전에서 긴급 수정이 필요할 때, master에서 분기하는 브랜치이다. 긴급 수정을 하는 동시에 develop 브랜치에서 아무러 작용없이 개발할 수 있어 나뉜 브랜치이며, 수정 후 master에 바로 머지를 한다. 이 또한 중요한 것은 수정 후 release 브랜치처럼 develop 브랜치에도 머지해야하는 것이다. 최종적으로 보는 흐름단어정리 브랜치(branch) : 직역하면 나뭇가지란 뜻으로 직역 뜻과 같이 나뭇가지 처럼 뻗어나가는 가지 중 한가지를 말하며 Git 개발 작업에서는 이를 하나의 작업라인을 말할 때 사용한다. QA Test : Quality Assurance Test로 품질 보증 시험으로 소프트웨어가 개발 되었을 때, 이것이 적절한 디자인 패턴을 적재적소에 사용해 확작성이 있고 유지보수가 좋은 코드인지, 기존 소프트웨어 보다 좋은 또는 편리한 기능을 제시하는지, 기존 소프트웨어보다 성능면에서 좋은지 검증하는 단계라 볼 수 있다. 머지(merge) : 병합이라는 뜻을 가진 것처럼 나뭇가지로 뻗어나간 수 많은 나뭇가지 중 어떠한 나뭇가지인 작업라인을 또다른 작업라인으로 병합 시켜준다는 말이다."
    } ,
  
    {
      "title"       : "JSON,XML,YAML",
      "category"    : "opinion",
      "tags"        : "front-end, datatype, basic",
      "url"         : "./JSON-XML-YAML.html",
      "date"        : "2023-04-28 00:00:00 +0900",
      "description" : "JSON,XML,YAML이 각각 무엇인지 그 차이가 뭔지 알아보자.",
      "content"     : "1. JSON (JavaScript Object Notation) 데이터를 저장, 전송할 때 사용되는 경량의 DATA 교환 형식 JavaScript에서 객체를 만들 때 사용하는 단순한 텍스트 형식인 표현식이다. 클라이언트와 서버가 주고 받는 요청(Request)와 응답(Response) 사이에 담겨있는 데이터의 형식 중 하나이다.-JSON은 데이터 포멧일 뿐이고 단순히 데이터를 표시하는 방법이다.[JSON 형식의 장점] 대부분의 프로그래밍 언어에서 JSON을 핸들링할 수 있도록 라이브러리를 제공한다. XML보다 최소한의 용량으로 데이터 전송이 가능하며, 구조 정의의 용이성과 가독성이 좋다. 내용이 최소한의 정보만 가지고 있기에 용량이 줄어들고 빠른 속도를 가지며, 언어가 독립적이고 사용하기 쉽다.[JSON 형식의 단점] 장점과 반대로 내용이 최소한의 정보만 가지고 있어 의미파악이 힘들다. 경량의 데이터 교환형식이기에 대용량의 데이터 송수신에는 부적합하다. XML은 사용처마다 요구되는 구조와 형태를 잘 갖췄는지 스키마를 이용해 검증이 가능하지만 JSON은 해당 기능을 지원하지 않는다. 주석을 달지 못하고, 문법 오류에 취약하다.[JSON 형식의 구조] JSON 형식의 구조는 key:value 형태의 구조를 가지고 있다. 중괄호 {}로 감싸며, 이는 객체(Object)가 나올 것을 의미한다. { \"나이\":30, \"이름\":\"홍길동\", \"특기\":[\"달리기\",\"수영\"]} 2. XML (Extensible Markup Language) XML은 데이터를 정의하는 규칙을 제공하는 markup 언어로 다른 프로그래밍 언어와는 다르게 자체적으로 컴퓨팅하는 작업을 수행할 수 없다. 대신 구조적 데이터 관리를 위해 모든 프로그래밍 언어 또는 소프트웨어를 구현할 수 있다. 태그라는 markup 기호를 사용하여 문서 내용에 영향을 주지 않고 사용하여 데이터의 유용성을 높인다.[XML의 특징] 표준성 : W3C에서 표준화를 주도, SGML과 HTML의 한계를 극복하기 위해 만든 표준 인터넷 언어이다. 분리성 : 표현과 내용이 분리되어 있고 XML 문서는 데이터의 구조와 내용을 기술하고 있으며, 스타일 시트를 이용하여 다양한 방식으로 데이터를 표현한다. 단순성 : XML 문서는 텍스트로 간단하게 되어 있어 하드웨어나 소프트웨어에 의존하지 않고 읽어 들일 수 있다는 장점이 있다. 호환성 : 위 단순성의 특성으로 다양한 시스템간에 상호 작용을 중계하는데 XML 사용이 가능하다. 수용성 : HTML과 같이 현재 인터넷에서 가장 많이 사용되는 HTTP 프로토콜을 이용하여 전달한다. 확장성 : XML은 확장성 있는 태그를 사용, 어떤 분야의 데이터도 명확하게 기술이 가능하다. SEQ : 문서의 의미 있는 태그를 사용하여 원하는 데이터를 쉽게 찾을 수 있는 장점이 있어 검색엔진최적화(SEQ)에 유리하다. [XML과 HTML] XML은 Data를 전달하는 것에 포커스를 맞춘 언어라면 HTML은 Data를 표현하는 것에 포커스를 맞춘 언어이다. HTML의 태그는 이미 약속한 태그만 사용이 가능하지만 XML은 사용자가 임의로 만들어서 사용이 가능합니다.~~~xml&lt;?xml version=”1.0” encoding=”UTF-8”?&gt; 사과, 바나나 양배추 일품라면 ---## 3. YAML (YAML Ain't Makeup Language)- YAML도 데이터 표현 양식의 한 종류이며 아래와 같은 특징을 가진다.[YAML의 특징]- yaml은 인간이 보고 이해하기 쉬운 형태를 가지고 있어 최근 많이 활용되는 데이터 포멧입니다.- 기본적으로 들여쓰기를 원칙으로 하며 JSON과 비슷하게 Key:Value 형태를 가지고 있다.~~~yamlServers: - name : Server1 administrator : Kim created : 20050103132749 status : active - name : Server2 administrator : Lee created : 20210101000000 status : active단어정리 W3C(World Wide Web Consortium) : 월드 와이드 웹을 위한 표준을 개발하고 관리하는 조직으로 팀 버너스리를 중심으로 설립된 조직이다."
    } ,
  
    {
      "title"       : "CSR/SSR,MAP/SPA",
      "category"    : "opinion",
      "tags"        : "front-end, basic",
      "url"         : "./CSR-SSR-MAP-SPA.html",
      "date"        : "2023-04-17 00:00:00 +0900",
      "description" : "CSR/SSR,MAP/SPA이 각각 무엇인지 그 차이가 뭔지 알아보자.",
      "content"     : "1. CSR (Client Side Renderring) CSR(Client Side Rendering)은 말 그대로 Client 측에서 렌더링(Rendering)이 이루어지는 방식을 말한다. CSR의 작업은 다음과 같은 순서로 이루어진다. 1) 클라이언트(브라우저)가 웹 서버에게 요청을 보낸다.2) Web 서버는 비어있는 HTML 문서인 index.html을 반환한다.(index.html은 비어있는 파일)3) HTML 문서에 있는 어플리케이션 자바스크립트 링크를 참고하여 웹 서버로부터 자바스크립트 파일을 다운받는다.4) 추가로 필요한 데이터가 있으면 서버에서 추가적으로 요청하여 가져온다.5) 사용자에게 화면을 보여준다. [CSR 방식의 장점] 빠른 인터렉션을 구현할 수 있다. View Rendering을 브라우저에게 담당시키므로서 서버 트레픽을 감소시키고, 사용자에게 더 빠른 인터렉션을 제공해준다. 새로고침이 발생하지 않아 사용자가 불편함을 느낄 수 있습니다.[CSR 방식의 단점] 첫 페이지 로딩 속도가 Server Side Rendering 보다 다소 느립니다. 검색엔진최적화(SEO)에 대한 추가 보완 작업이 필요하다.2. SSR (Server Side Rendering) SSR(Server Side Rendering)은 CSR 방식과 다르게 Server에서 User에게 보여줄 화면을 미리 페이지를 모두 구성하여 렌더링이 이루어지는 방식을 말한다. SSR의 작업은 다음과 같은 순서로 이루어진다. 1) CSR과 다르게 웹 서버에서 비어있는 HTML 파일이 아닌 완성된 HTML 문서와 동적으로 처리 가능한 코드를 가져온다.2) CSR과 다르게 서버에 두번 요청할 필요없이 클라이언트에서 바로 User에게 화면을 보여준다. [SSR 방식의 장점] 완성된 형태의 HTML 파일을 서버로 부터 받으므로 크롤링하기에 적합, 검색엔진최적화(SEO) 관점에서 유리하다. 서버에 이미 로딩을 완료해서오므로 첫 로딩 시간이 매우 짧다.[SSR 방식의 단점] 페이지 요청시 서버에서 페이지를 받아오므로 깜박이는 현상이 나타나 UX는 좋지 않다는 단점이 있다. 화면에서 바꾸지 않아도 되는 부분을 계속하여 렌더링을 하여 서버가 과부화되기 쉽다. 사용자가 동적 움직임을 보일 때, 서버에서 계속하여 데이터를 가져오기 때문에 과부하되기 쉽다. 처음 HTML 문서를 받을 때, TTV가 먼저 일어나고 이후 클릭을 해야 TTI가 일어나기에 사용자가 빠르게 웹 사이트를 볼 수 있지만 TTV와 TTI의 공백이 길어 반응이 없을 수도 있다.3. SPA (Single Page Aplication) SPA는 CSR 방식을 사용하는 하나의 Page로 구성된 Application이다. 하지만 react, vue, angular 등이 있고 특히 react는 Next.js와 Gatsby.js에서 SSG을 제공하기 때문에 SPA라고 모두 CSR 방식을 사용하는 것은 아니다. 처음 요청 시 딱 한 페이지만 불러오고 페이지 이동 시 기존 페이지에서 내부를 수정하여 보여주는 방식이다. 이에 페이지 리로딩 없이 서버에서 내부 수정 시 필요한 데이터만 가져온다.[SPA 방식의 장점] 필요한 리소스만 부분적으로 로딩하여 클라이언트가 처음 요청한 정적 리소스와 추가적인 데이터는 모두 캐시에 저장된다. 페이지의 부분적인 요소만 갱신하기 때문에 전체적으로 트레픽이 감소한다. 페이지를 새로고침하지 않기 때문에 UX(User Experience)에서 매우 좋다.[SPA 방식의 단점] Web Application에 필요한 정적 리소스를 한번에 다운로드 받기에 초기에 구동 속도가 느리다. 검색 엔진이 크롤링할 때, Application이 로드 되기 전에 빈 상태의 코드를 크롤링하게 검색엔진최적화(SEO)가 어렵다. SSR에선 사용자의 정보를 서버측에서 관리하지만 CSR 방식은 클라이언트에서 가져오기에 정보를 저장할 공간이 마땅치 않아 보안이 취약하다.4. MPA (Multiple Page Application) MPA는 SSR 방식을 사용하는 여러개의 Page로 구성된 Application이다. SPA와는 다르게 새로운 페이지를 요청할 때마다 정적 리소스를 가져와 전체 페이지를 다시 렌더링한다.[MPA 방식의 장점] User가 보는 화면이 Web 크롤링 화면이랑 방식이 같아 SEO에 좋다. SPA 방식보다 써오던 방식과 역사가 길어 초보자들도 다양한 튜토리얼,해결법,프레임워크로 좋은 환경에서 제작할 수 있다.[MPA 방식의 단점] 다른 페이지 이동 시, 페이지를 새로 로딩하기에 UX가 좋지 않다. 요청이 들어올 때마다 새로 패치하기에 속도가 느리다. 프론트앤드와 백앤드가 확실하게 구분되어 있지 않고 연결성이 높아 서버쪽,클라이언트쪽 언어가 모두 필요하다.단어정리 렌더링(Rendering) : html.js 파일을 각 단계를 거쳐 User에게 보여주는 것으로 각 단계는 아래와 같다. 1) Parsing : 브라우저가 html 파일을 읽어 트리 자료형으로 해석하는 단계 2) Style : parsing 단계에서 만들어진 트리에서 실제로 브라우저에 띄울 데이터를 트리로 자료형으로 정리해주는 단계3) Layout : Style 작업으로 만들어진 트리의 요소를 화면에 어떻게 배치할지 계산해주는 단계4) Paint : Layout 단계에서 계산된 값을 화면상에 실제 픽셀로 찍어주는 단계5) Composite : Paint 단계에서 생성된 레이어를 최종 합성해서 화면에 띄워주는 단계 인터렉션(Interation) : 단어의 뜻 그대로 Interface와 User가 서로 행동과 반응이 이어지 듯, 두 개체의 상호작용을 이야기 한다. 검색엔진최적화(SEO:Search Engine Optimization) : 검색엔진 결과 페이지에서 사용자의 검색 결과에 대하여 웹 페이지의 상위 노출도를 높이는 작업이다. TTV(Time To View) : 사용자가 웹 사이트를 볼 수 있는 시간이다. TTI(Time To Interact) : 사용자가 웹에서 동적인 활동이 가능하게 되는 시간이다. UX(User Experience) : 단어의 뜻 그래도 사용자의 경험이란 뜻으로 UI에서 느끼는 사용자들의 느낌, 태도, 행동 등을 말하며 UX가 좋을 수록 사용자는 UI에서 편안함을 느낀다 할 수 있따."
    } ,
  
    {
      "title"       : "Interface란?",
      "category"    : "opinion",
      "tags"        : "front-end, basic",
      "url"         : "./Interface.html",
      "date"        : "2023-04-16 00:00:00 +0900",
      "description" : "Interface가 무엇인지, 종류와 Java언어로 기본적인 인터페이스 구성을 알아보자",
      "content"     : "1. Interface란? 인터페이스(interface)란 서로 다른 두 개 이상의 독립된 시스템 또는 장치 간의 정보를 교환하는 공유경계(shared boundary)를 말한다. 컴퓨터와 사용자의 간에 통신이 가능하도록 하는 프로그램 또는 장치를 말한다. 이러한 interface는 상호작용하는 대상 관계에 따라 크게 하드웨어 인터페이스, 소프트웨어 인터페이스, 사용자 인터페이스로 3가지로 나눌 수 있습니다.2. 하드웨어 인터페이스 (Hardware Interface) 상호작용하는 대상이 물리적인 기기인 인터페이스로 서로 다른 물리적인 기기를 연결해주는 역할을 한다. 대표적인 하드웨어 인터페이스로는 USB Interface가 있다. USB는 ‘Universal Serial Bus’의 약자로 컴퓨터와 주변 장치를 연결하기 위해 1996년에 만들어진 통일된 연결방법으로 대표적인 하드웨어 인터페이스이다.3. 소프트웨어 인터페이스 (Software Interface) 상호작용하는 대상이 소프트웨어와 하드웨어로 이를 소프트웨어를 통하여 하드웨어의 동작을 지시하고 제어할 수 있도록 연결해주는 역할을 한다. 대표적인 소프트웨어 인터페이스로는 API가 있다. API는 ‘Application Programming Interface’의 약자로 응용 프로그램 간에 호환이 가능하도록 상호 작용하는 방식을 정해둔 대표적인 소프트웨어 인터페이스이다.4. 사용자 인터페이스 (User Interface) 상호작용하는 대상이 사람과 컴퓨터로 사용자가 컴퓨터를 제어할 수 있도록 연결해주는 역할을 한다. 초기에는 CLI(Command Line Interface)라는 인터페이스를 통하여 사용자가 컴퓨터가 수행할 작업을 지시하고 제어했으나 사용하기 까다로워 사용자가 사용하기에 어렵지 않은 대표적인 사용자 인터페이스인 GUI를 만들었다. GUI는 ‘Graphical User Interface’의 약자로 그래픽 요소를 사용해 컴퓨터에게 보내는 명령을 직관적으로 알기 쉽게 아이콘 등으로 나타낸 대표적인 사용자 인터페이스이다.5. Interface 마무리 본 게시글은 위와 같이 Interface란 무엇인지에 관하여 사전적 의미를 정리했다. 하지만 앞으로 front-end 개발을 위해 정의 뿐만 아니라 Interface를 어떻게 구성해야 하는지 알고 넘어갈 필요가 있다. Interface의 중요한 점은 직관성(Intution)이다. 다음 사진을 보고 어디에 사용하는 물건인지 생각해보자. 사진을 보았을 땐 폭탄이 터질 것 같은 모습에 압력 장치, 잠금 장치도 보이는 흡사 무시무시한 무기를 저장할 것 같은 그런 기계로 보인다. 하지만 놀랍게도 이는 그냥 팝콘 튀기는 장치이다. 대부분의 사람들은 팝콘을 알지만 저 물건을 맞춘 사람은 소수일 것이다. 이는 저 기계가 사용자가 사용하기엔 직관성이 떨어지는 인터페이스들을 가지고 있기 때문이다. 이번엔 다른 예시를 보자. 이 사진을 보자마자 여러분은 이것이 어디에 사용하는 물건인지 바로 알아차렸을 것이라 생각한다. 두꺼운 철판과 손잡이 그리고 버튼들 이 인터페이스의 구성으로 우리는 하드웨어의 정체성을 바로 파악할 수 있었다. 이처럼 인터페이스는 상호작용의 경계면의 역할 뿐이 아니라 존재 자체로 우리에게 정보를 전달 해주는 역할도 한다고 볼 수 있다. 위와 같은 예시로 Interface를 통하여 생각보다 많은 정보를 사용자에게 줄 수 있다는 점에서 다양한 시각으로 구성해야 한다는 점을 알 수 있다.단어정리 공유경계(shared boundary) : 특정기준으로 나누어진 사물 또는 공간을 공유하는 교집합의 빈 공간을 말한다. 즉, A와 B의 교집합이 공집합인 A와 B의 공유경계 S는 각각 A,B의 교집합 관계에서 공집합을 가지지 않음을 말한다."
    } 
  
]
